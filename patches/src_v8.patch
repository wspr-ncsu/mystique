diff --git a/BUILD.gn b/BUILD.gn
index 94eb389748..b79c4d00cb 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -936,6 +936,8 @@ v8_source_set("v8_base") {
     "src/codegen.cc",
     "src/codegen.h",
     "src/collector.h",
+    "src/commons.h",
+    "src/commons.cc",
     "src/compilation-cache.cc",
     "src/compilation-cache.h",
     "src/compilation-dependencies.cc",
@@ -1553,6 +1555,8 @@ v8_source_set("v8_base") {
     "src/runtime/runtime-simd.cc",
     "src/runtime/runtime-strings.cc",
     "src/runtime/runtime-symbol.cc",
+    "src/runtime/runtime-taint.h",
+    "src/runtime/runtime-taint.cc",
     "src/runtime/runtime-test.cc",
     "src/runtime/runtime-typedarray.cc",
     "src/runtime/runtime-utils.h",
diff --git a/include/v8.h b/include/v8.h
index d7e39adbae..a81c1a4ab0 100644
--- a/include/v8.h
+++ b/include/v8.h
@@ -307,6 +307,11 @@ class Local {
   V8_INLINE static Local<T> New(Isolate* isolate,
                                 const PersistentBase<T>& that);
 
+  // TaintAnalysis:: Making this public.
+  explicit V8_INLINE Local(T* that) : val_(that) {}
+
+  V8_INLINE Local<T> MakePersistentCopy();
+
  private:
   friend class Utils;
   template<class F> friend class Eternal;
@@ -334,7 +339,6 @@ class Local {
   template <class F>
   friend class ReturnValue;
 
-  explicit V8_INLINE Local(T* that) : val_(that) {}
   V8_INLINE static Local<T> New(Isolate* isolate, T* that);
   T* val_;
 };
@@ -886,6 +890,9 @@ class V8_EXPORT HandleScope {
   static internal::Object** CreateHandle(internal::Isolate* isolate,
                                          internal::Object* value);
 
+  static internal::Object** CreatePersistentHandle(internal::Isolate* isolate,
+                                                   internal::Object* value);
+
  private:
   // Uses heap_object to obtain the current Isolate.
   static internal::Object** CreateHandle(internal::HeapObject* heap_object,
@@ -1107,6 +1114,9 @@ class V8_EXPORT Script {
    * Returns the corresponding context-unbound script.
    */
   Local<UnboundScript> GetUnboundScript();
+
+  void SetTaint(Local<String> report);
+  bool IsTainted();
 };
 
 
@@ -1688,6 +1698,19 @@ class V8_EXPORT NativeWeakMap : public Data {
  */
 class V8_EXPORT Value : public Data {
  public:
+  void Print();
+
+  Isolate *GetIsolate();
+
+  bool IsHeapAllocated();
+
+  void SetTaint(std::vector<bool> tainted_bytes=std::vector<bool>());
+  bool IsTainted();
+
+  std::vector<bool> GetTaintedBytes();
+
+  void PrintTaintSinkDetails(Isolate *isolate, FILE *out);
+
   /**
    * Returns true if this value is the undefined value.  See ECMA-262
    * 4.3.10.
@@ -6460,6 +6483,12 @@ class V8_EXPORT Isolate {
    */
   bool IsInUse();
 
+  void MarkAsExtensionContext(Local<Context> context, bool is_background);
+
+  bool IsThirdPartySetCookie(Local<String> cookieURL);
+
+  bool InHoneyPage();
+
  private:
   template <class K, class V, class Traits>
   friend class PersistentValueMapBase;
@@ -7785,6 +7814,23 @@ Local<T> Local<T>::New(Isolate* isolate, T* that) {
 }
 
 
+template <class T>
+Local<T> Local<T>::MakePersistentCopy() {
+  Local<T> ret(*this);
+
+  internal::Object **slot = reinterpret_cast<internal::Object **>(this->val_);
+  if ((*this)->IsHeapAllocated()) {
+    internal::Isolate *isolate =
+        reinterpret_cast<internal::Isolate *>((*this)->GetIsolate());
+    internal::Object **new_slot =
+        HandleScope::CreatePersistentHandle(isolate, *slot);
+    ret = Local<T>(reinterpret_cast<T *>(new_slot));
+  }
+
+  return ret;
+}
+
+
 template<class T>
 template<class S>
 void Eternal<T>::Set(Isolate* isolate, Local<S> handle) {
diff --git a/src/api.cc b/src/api.cc
index 6858a325c4..b3141c825f 100644
--- a/src/api.cc
+++ b/src/api.cc
@@ -72,6 +72,8 @@
 #include "src/vm-state-inl.h"
 #include "src/wasm/wasm-module.h"
 
+#include <iostream>
+
 namespace v8 {
 
 #define LOG_API(isolate, class_name, function_name)                       \
@@ -894,6 +896,12 @@ i::Object** HandleScope::CreateHandle(i::HeapObject* heap_object,
 }
 
 
+i::Object** HandleScope::CreatePersistentHandle(i::Isolate* isolate,
+                                                i::Object* value) {
+  return i::HandleScope::CreatePersistentHandle(isolate, value);
+}
+
+
 EscapableHandleScope::EscapableHandleScope(Isolate* v8_isolate) {
   i::Isolate* isolate = reinterpret_cast<i::Isolate*>(v8_isolate);
   escape_slot_ = CreateHandle(isolate, isolate->heap()->the_hole_value());
@@ -2249,6 +2257,19 @@ Local<Script> Script::Compile(v8::Local<String> source,
 }
 
 
+void Script::SetTaint(Local<String> report) {
+  i::Handle<i::JSFunction> function = Utils::OpenHandle(this);
+  i::Isolate* isolate = function->GetIsolate();
+  isolate->MarkAsTaintSource(function);
+  isolate->TaintJSFunction(function, Utils::OpenHandle(*report));
+}
+
+
+bool Script::IsTainted() {
+  return false;
+}
+
+
 // --- E x c e p t i o n s ---
 
 
@@ -2834,6 +2855,84 @@ MaybeLocal<String> JSON::Stringify(Local<Context> context,
 
 // --- D a t a ---
 
+
+void Value::Print() {
+  i::Handle<i::Object> object = Utils::OpenHandle(this);
+  object->Print();
+}
+
+
+Isolate *Value::GetIsolate() {
+  i::Handle<i::Object> object = Utils::OpenHandle(this);
+  if (object->IsHeapObject()) {
+    i::Isolate *isolate = i::HeapObject::cast(*object)->GetIsolate();
+    return reinterpret_cast<Isolate *>(isolate);
+  }
+  return NULL;
+}
+
+
+bool Value::IsHeapAllocated() {
+  i::Handle<i::Object> object = Utils::OpenHandle(this);
+  return object->IsHeapObject();
+}
+
+
+void Value::SetTaint(std::vector<bool> tainted_bytes) {
+  i::Handle<i::Object> object = Utils::OpenHandle(this);
+  CHECK(object->IsHeapObject());  // No Smi.
+
+  i::Isolate *isolate = i::HeapObject::cast(*object)->GetIsolate();
+  i::JavaScriptFrameIterator it(isolate);
+  if (!it.done()) {
+    i::Handle<i::JSFunction> function(it.frame()->function());
+    if (isolate->InExtensionContext(function) &&
+        !isolate->IsBackgroundPageContext(function)) {
+      isolate->MarkAsTaintSource(function);
+      isolate->SetTaintForV8Object(object, tainted_bytes);
+      isolate->SetV8ObjectAsTaintSource(object, function);
+    }
+  }
+}
+
+
+bool Value::IsTainted() {
+  i::Handle<i::Object> object = Utils::OpenHandle(this);
+  if (object->IsHeapObject()) {
+    i::Isolate *isolate = i::HeapObject::cast(*object)->GetIsolate();
+    return isolate->IsV8ObjectTainted(object);
+  }
+  return false;
+}
+
+
+std::vector<bool> Value::GetTaintedBytes() {
+  i::Handle<i::Object> object = Utils::OpenHandle(this);
+  if (object->IsString()) {
+    i::Isolate *isolate = i::HeapObject::cast(*object)->GetIsolate();
+    std::vector<bool> *tainted_bytes =
+        isolate->GetStringTaintedBytes(i::Handle<i::String>::cast(object));
+    if (tainted_bytes != NULL)
+      return *tainted_bytes;
+  }
+  return std::vector<bool>();
+}
+
+
+void Value::PrintTaintSinkDetails(Isolate *isolate, FILE *out) {
+  i::Handle<i::Object> object = Utils::OpenHandle(this);
+  fprintf(out, "** Sink object: ");
+  if (object->IsString()) {
+    i::Handle<i::String> str = i::Handle<i::String>::cast(object);
+    fprintf(out, "%s", str->ToCString().get());
+  } else {
+    object->ShortPrint(out);
+  }
+  fprintf(out, "\n\n");
+  reinterpret_cast<i::Isolate *>(isolate)->PrintPropagationPaths(object, out);
+}
+
+
 bool Value::FullIsUndefined() const {
   i::Handle<i::Object> object = Utils::OpenHandle(this);
   bool result = false;
@@ -8025,6 +8124,105 @@ void Isolate::VisitWeakHandles(PersistentHandleVisitor* visitor) {
 }
 
 
+void Isolate::MarkAsExtensionContext(Local<Context> context,
+                                     bool is_background) {
+  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(this);
+  isolate->MarkAsExtensionContext(Utils::OpenHandle(*context), is_background);
+}
+
+
+static bool IsSameOrigin(i::Handle<i::String> cookieURL,
+                         i::Handle<i::String> js_src) {
+  std::unique_ptr<char[]> cookieURL_chars = cookieURL->ToCString();
+  std::unique_ptr<char[]> js_src_chars = js_src->ToCString();
+  std::string c_cookieURL(cookieURL_chars.get());
+  std::string c_js_src(js_src_chars.get());
+
+  if (c_cookieURL.find("http") != 0) {  // Not likely?
+    printf("[!]: %s\n", c_cookieURL.c_str());
+    return true;
+  }
+
+  if (c_js_src.find("http") != 0)
+    return true;
+
+  int l_start = c_cookieURL.find("://");
+  int r_start = c_js_src.find("://");
+  CHECK(l_start != -1 && r_start != -1);
+  l_start += 3;
+  r_start += 3;
+
+  int l_end = c_cookieURL.find("/", l_start);
+  int r_end = c_js_src.find("/", r_start);
+  if (l_end == -1)
+    l_end = c_cookieURL.length();
+  if (r_end == -1)
+    r_end = c_js_src.length();
+
+  std::string cookie_domain = c_cookieURL.substr(l_start, l_end - l_start);
+  std::string js_domain = c_js_src.substr(r_start, r_end - r_start);
+
+  int matches = 0;
+  std::string last_component;
+  int l_prev = cookie_domain.length(), r_prev = js_domain.length();
+  for (int i = l_prev - 1, j = r_prev - 1;
+      i >= 0 && j >= 0 && cookie_domain[i] == js_domain[j]; i--, j--) {
+    if (cookie_domain[i] == '.' || i == 0) {
+      matches += 1;
+      last_component = (i == 0) ? cookie_domain.substr(0, l_prev) :
+          cookie_domain.substr(i + 1, l_prev);
+      l_prev = i;
+      r_prev = j;
+    }
+  }
+
+  /*
+  printf("[1] %s\n", cookie_domain.c_str());
+  printf("[2] %s\n", js_domain.c_str());
+  printf("[3] %d, %s\n", matches, last_component.c_str());
+  */
+  if (matches <= 1)
+    return false;
+
+  if (matches == 2) {
+    // TODO: This list below is WIP and is by no means complete.
+    // The purpose here is to make sure the second match is not
+    // due to something like ".edu.cn".
+    if (last_component == "edu" || last_component == "co") // etc
+      return false;
+  }
+
+  return true;
+}
+
+
+bool Isolate::IsThirdPartySetCookie(Local<String> cookieURL) {
+  i::Isolate *isolate = reinterpret_cast<i::Isolate*>(cookieURL->GetIsolate());
+  for (i::JavaScriptFrameIterator it(isolate); !it.done(); it.Advance()) {
+    i::Handle<i::JSFunction> function(it.frame()->function());
+    i::Handle<i::SharedFunctionInfo> shared(function->shared());
+    if (shared->IsBuiltin() || shared->script()->IsUndefined(isolate))
+      continue;
+
+    i::Handle<i::Script> script(i::Script::cast(shared->script()));
+    if (i::Script::GetNameOrSourceURL(script)->IsUndefined(isolate))
+      continue;
+
+    i::Handle<i::String> js_src = i::Handle<i::String>::cast(
+        i::Script::GetNameOrSourceURL(script));
+    if (!IsSameOrigin(Utils::OpenHandle(*cookieURL), js_src))
+      return true;
+  }
+  return false;
+}
+
+
+bool Isolate::InHoneyPage() {
+  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(this);
+  return isolate->InHoneyPage();
+}
+
+
 MicrotasksScope::MicrotasksScope(Isolate* isolate, MicrotasksScope::Type type)
     : isolate_(reinterpret_cast<i::Isolate*>(isolate)),
       run_(type == MicrotasksScope::kRunMicrotasks) {
diff --git a/src/assert-scope.h b/src/assert-scope.h
index 84e6990b04..03f3c1aeeb 100644
--- a/src/assert-scope.h
+++ b/src/assert-scope.h
@@ -105,11 +105,11 @@ typedef PerThreadAssertScopeDebugOnly<HANDLE_ALLOCATION_ASSERT, true>
     AllowHandleAllocation;
 
 // Scope to document where we do not expect any allocation and GC.
-typedef PerThreadAssertScopeDebugOnly<HEAP_ALLOCATION_ASSERT, false>
+typedef PerThreadAssertScope<HEAP_ALLOCATION_ASSERT, false>
     DisallowHeapAllocation;
 
 // Scope to introduce an exception to DisallowHeapAllocation.
-typedef PerThreadAssertScopeDebugOnly<HEAP_ALLOCATION_ASSERT, true>
+typedef PerThreadAssertScope<HEAP_ALLOCATION_ASSERT, true>
     AllowHeapAllocation;
 
 // Scope to document where we do not expect any handle dereferences.
diff --git a/src/bootstrapper.cc b/src/bootstrapper.cc
index 5142817986..412bc51061 100644
--- a/src/bootstrapper.cc
+++ b/src/bootstrapper.cc
@@ -1663,9 +1663,11 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
     Handle<JSObject> json_object = factory->NewJSObject(cons, TENURED);
     DCHECK(json_object->IsJSObject());
     JSObject::AddProperty(global, name, json_object, DONT_ENUM);
+    /*
     SimpleInstallFunction(json_object, "parse", Builtins::kJsonParse, 2, false);
     SimpleInstallFunction(json_object, "stringify", Builtins::kJsonStringify, 3,
                           true);
+    */
     JSObject::AddProperty(
         json_object, factory->to_string_tag_symbol(),
         factory->NewStringFromAsciiChecked("JSON"),
diff --git a/src/code-stub-assembler.cc b/src/code-stub-assembler.cc
index 3ff4ff9b19..e215a26044 100644
--- a/src/code-stub-assembler.cc
+++ b/src/code-stub-assembler.cc
@@ -2178,6 +2178,7 @@ Node* CodeStubAssembler::StringFromCharCode(Node* code) {
          &if_codeisonebyte, &if_codeistwobyte);
   Bind(&if_codeisonebyte);
   {
+    /*
     // Load the isolate wide single character string cache.
     Node* cache = LoadRoot(Heap::kSingleCharacterStringCacheRootIndex);
 
@@ -2207,6 +2208,14 @@ Node* CodeStubAssembler::StringFromCharCode(Node* code) {
       var_result.Bind(entry);
       Goto(&if_done);
     }
+    */
+
+    Node* result = AllocateSeqOneByteString(1);
+    StoreNoWriteBarrier(
+        MachineRepresentation::kWord8, result,
+        IntPtrConstant(SeqOneByteString::kHeaderSize - kHeapObjectTag), code);
+    var_result.Bind(result);
+    Goto(&if_done);
   }
 
   Bind(&if_codeistwobyte);
diff --git a/src/commons.cc b/src/commons.cc
new file mode 100644
index 0000000000..2a51e887fe
--- /dev/null
+++ b/src/commons.cc
@@ -0,0 +1,290 @@
+#include "src/commons.h"
+#include <cstddef>
+
+namespace v8 {
+namespace commons {
+
+void LinkedList::initialize() {
+  fake_head_.prev = fake_tail_.next = NULL;
+  fake_head_.next = &fake_tail_;
+  fake_tail_.prev = &fake_head_;
+  size_ = 0;
+}
+
+
+void LinkedList::destroy() {
+  ListNode *prev, *cur;
+  for (cur = fake_head_.next; cur != &fake_tail_; ) {
+    prev = cur;
+    cur = cur->next;
+    delete prev;
+  }
+  initialize();
+}
+
+
+LinkedList::LinkedList() {
+  initialize();
+}
+
+
+LinkedList::~LinkedList() {
+  destroy();
+}
+
+
+static void IterateLinkedListCopy(void *key, void *value, void *data) {
+  LinkedList *list = (LinkedList *)data;
+  list->append(key, value);
+}
+
+
+LinkedList &LinkedList::operator=(const LinkedList &other) {
+  destroy();
+  other.iterate(IterateLinkedListCopy, this);
+  return *this;
+}
+
+
+LinkedList::LinkedList(LinkedList &other) {
+  initialize();
+  other.iterate(IterateLinkedListCopy, this);
+}
+
+
+void LinkedList::prepend(void *key, void *value) {
+  ListNode *node = new ListNode();
+  node->key = key;
+  node->value = value;
+
+  node->next = fake_head_.next;
+  node->prev = &fake_head_;
+  fake_head_.next->prev = node;
+  fake_head_.next = node;
+
+  size_ += 1;
+}
+
+
+void LinkedList::append(void *key, void *value) {
+  ListNode *node = new ListNode();
+  node->key = key;
+  node->value = value;
+
+  node->next = &fake_tail_;
+  node->prev = fake_tail_.prev;
+  fake_tail_.prev->next = node;
+  fake_tail_.prev = node;
+
+  size_ += 1;
+}
+
+
+void LinkedList::remove(void *key) {
+  ListNode *cur;
+  for (cur = &fake_head_; cur->next != &fake_tail_ &&
+      cur->next->key != key; cur = cur->next) {
+    ;
+  }
+  if (cur->next != &fake_tail_) {
+    ListNode *p = cur->next;
+    cur->next = p->next;
+    p->next->prev = cur;
+    delete p;
+    size_ -= 1;
+  }
+}
+
+
+bool LinkedList::search(void *key) {
+  for (ListNode *cur = fake_head_.next; cur != &fake_tail_; cur = cur->next)
+    if (cur->key == key)
+      return true;
+  return false;
+}
+
+
+void *LinkedList::get(void *key) {
+  for (ListNode *cur = fake_head_.next; cur != &fake_tail_; cur = cur->next)
+    if (cur->key == key)
+      return cur->value;
+  return NULL;
+}
+
+
+void LinkedList::iterate(IterateCallback callback, void *data) const {
+  for (ListNode *cur = fake_head_.next; cur != &fake_tail_; cur = cur->next)
+    callback(cur->key, cur->value, data);
+}
+
+
+bool LinkedList::empty() { return (size_ == 0); }
+
+
+void *LinkedList::head_key() {
+  if (!empty())
+    return fake_head_.next->key;
+  return NULL;
+}
+
+
+void *LinkedList::head_value() {
+  if (!empty())
+    return fake_head_.next->value;
+  return NULL;
+}
+
+
+void *LinkedList::tail_key() {
+  if (!empty())
+    return fake_tail_.prev->key;
+  return NULL;
+}
+
+
+void *LinkedList::tail_value() {
+  if (!empty())
+    return fake_tail_.prev->value;
+  return NULL;
+}
+
+
+void LinkedList::pop_head() {
+  if (!empty()) {
+    ListNode *p = fake_head_.next;
+    fake_head_.next = p->next;
+    p->next->prev = &fake_head_;
+    delete p;
+    size_ -= 1;
+  }
+}
+
+
+void LinkedList::pop_tail() {
+  if (!empty()) {
+    ListNode *p = fake_tail_.prev;
+    fake_tail_.prev = p->prev;
+    p->prev->next = &fake_tail_;
+    delete p;
+    size_ -= 1;
+  }
+}
+
+
+void LinkedList::clear() {
+  destroy();
+}
+
+
+HashTable::HashTable() {
+  buckets_ = new LinkedList[kMinCapacity];
+  capacity_ = kMinCapacity;
+  size_ = 0;
+}
+
+
+HashTable::~HashTable() {
+  delete[] buckets_;
+  buckets_ = NULL;
+  capacity_ = 0;
+  size_ = 0;
+}
+
+
+int HashTable::hash_pointer(void *ptr, int mod) {
+  unsigned long hash = reinterpret_cast<unsigned long>(ptr);
+  hash = ~hash + (hash << 18);  // hash = (hash << 18) - hash - 1;
+  hash = hash ^ (hash >> 31);
+  hash = hash * 21;  // hash = (hash + (hash << 2)) + (hash << 4);
+  hash = hash ^ (hash >> 11);
+  hash = hash + (hash << 6);
+  hash = hash ^ (hash >> 22);
+  hash = hash % ((unsigned long)mod);
+
+  CHECK((int)hash >= 0 && (int)hash < mod);
+  return hash;
+}
+
+
+void HashTable::insert(void *key, void *value) {
+  remove(key);  // Overwrite if duplicate key.
+  int idx = hash_pointer(key, capacity_);
+  buckets_[idx].append(key, value);
+  size_ += 1;
+  check_load_factor();
+}
+
+
+void HashTable::remove(void *key) {
+  int idx = hash_pointer(key, capacity_);
+  if (buckets_[idx].search(key)) {
+    buckets_[idx].remove(key);
+    size_ -= 1;
+    check_load_factor();
+  }
+}
+
+
+bool HashTable::search(void *key) {
+  int idx = hash_pointer(key, capacity_);
+  return buckets_[idx].search(key);
+}
+
+
+void *HashTable::get(void *key) {
+  int idx = hash_pointer(key, capacity_);
+  return buckets_[idx].get(key);
+}
+
+
+void HashTable::clear() {
+  delete[] buckets_;
+  buckets_ = new LinkedList[kMinCapacity];
+  capacity_ = kMinCapacity;
+  size_ = 0;
+}
+
+
+void HashTable::iterate(IterateCallback callback, void *data) {
+  for (int idx = 0; idx < capacity_; idx++) {
+    buckets_[idx].iterate(callback, data);
+  }
+}
+
+
+bool HashTable::empty() { return (size_ == 0); }
+
+
+struct ResizeHashTable_Data {
+  LinkedList *new_buckets;
+  int new_capacity;
+};
+
+void HashTable::Iterate_ResizeHashTable(void *key, void *value, void *data) {
+  ResizeHashTable_Data *d = static_cast<ResizeHashTable_Data *>(data);
+  int idx = hash_pointer(key, d->new_capacity);
+  d->new_buckets[idx].append(key, value);
+}
+
+
+void HashTable::resize_table(int new_capacity) {
+  LinkedList *new_buckets = new LinkedList[new_capacity];
+  ResizeHashTable_Data data = { new_buckets, new_capacity };
+  this->iterate(Iterate_ResizeHashTable, &data);
+  delete[] buckets_;
+  buckets_ = new_buckets;
+  capacity_ = new_capacity;
+}
+
+
+void HashTable::check_load_factor() {
+  int upper_limit = (capacity_ / 4) * 3;
+  int lower_limit = (capacity_ / 4);
+  if (size_ < lower_limit && capacity_ / 2 >= kMinCapacity)
+    resize_table(capacity_ / 2);
+  else if (size_ > upper_limit)
+    resize_table(capacity_ * 2);
+}
+
+}  // namespace commons
+}  // namespace v8
diff --git a/src/commons.h b/src/commons.h
new file mode 100644
index 0000000000..6f1c800fb5
--- /dev/null
+++ b/src/commons.h
@@ -0,0 +1,98 @@
+#ifndef V8_COMMONS_H_
+#define V8_COMMONS_H_
+
+#include "src/base/logging.h"
+
+namespace v8 {
+namespace commons {
+
+typedef void (*IterateCallback)(void *key, void *value, void *data);
+
+// Doubly-linked list.
+class LinkedList {
+ public:
+  LinkedList();
+
+  LinkedList(LinkedList &other);
+
+  ~LinkedList();
+
+  LinkedList &operator=(const LinkedList &other);
+
+  bool empty();
+
+  void prepend(void *key, void *value);
+  void append(void *key, void *value);
+  void remove(void *key);
+  bool search(void *key);
+  void *get(void *key);
+
+  void *head_key();
+  void *head_value();
+  void *tail_key();
+  void *tail_value();
+
+  void pop_head();
+  void pop_tail();
+
+  void clear();
+
+  void iterate(IterateCallback callback, void *data) const;
+
+  int size() { return size_; }
+
+ private:
+  void initialize();
+  void destroy();
+
+  struct ListNode {
+    void *key;
+    void *value;
+    struct ListNode *prev;
+    struct ListNode *next;
+  };
+
+  ListNode fake_head_;
+  ListNode fake_tail_;
+  int size_;
+};
+
+
+// Hash with chaining.
+class HashTable {
+ public:
+  HashTable();
+
+  ~HashTable();
+
+  bool empty();
+
+  void insert(void *key, void *value);
+  void remove(void *key);
+  bool search(void *key);
+  void *get(void *key);
+
+  void clear();
+
+  void iterate(IterateCallback callback, void *data);
+
+  int size() { return size_; }
+
+ private:
+  static int hash_pointer(void *ptr, int mod);
+
+  static void Iterate_ResizeHashTable(void *key, void *value, void *data);
+  void resize_table(int new_capacity);
+  void check_load_factor();
+
+  static const int kMinCapacity = 8;
+
+  LinkedList *buckets_;
+  int capacity_;  // Number of buckets.
+  int size_;      // Total number of keys.
+};
+
+}  // namespace commons
+}  // namespace v8
+
+#endif
diff --git a/src/factory.cc b/src/factory.cc
index bedcb9b61a..3f8dca6111 100644
--- a/src/factory.cc
+++ b/src/factory.cc
@@ -433,6 +433,7 @@ MaybeHandle<SeqTwoByteString> Factory::NewRawTwoByteString(
 
 Handle<String> Factory::LookupSingleCharacterStringFromCode(uint32_t code) {
   if (code <= String::kMaxOneByteCharCodeU) {
+    /*
     {
       DisallowHeapAllocation no_allocation;
       Object* value = single_character_string_cache()->get(code);
@@ -446,6 +447,13 @@ Handle<String> Factory::LookupSingleCharacterStringFromCode(uint32_t code) {
         InternalizeOneByteString(Vector<const uint8_t>(buffer, 1));
     single_character_string_cache()->set(code, *result);
     return result;
+    */
+
+    Handle<SeqOneByteString> result =
+        NewRawOneByteString(1, TENURED).ToHandleChecked();
+    uint8_t* dest = result->GetChars();
+    dest[0] = static_cast<uint8_t>(code);
+    return result;
   }
   DCHECK(code <= String::kMaxUtf16CodeUnitU);
 
@@ -455,13 +463,17 @@ Handle<String> Factory::LookupSingleCharacterStringFromCode(uint32_t code) {
 }
 
 
+/*
 // Returns true for a character in a range.  Both limits are inclusive.
 static inline bool Between(uint32_t character, uint32_t from, uint32_t to) {
   // This makes uses of the the unsigned wraparound.
   return character - from <= to - from;
 }
+*/
 
 
+// Now we can completely get rid of this.
+/*
 static inline Handle<String> MakeOrFindTwoCharacterString(Isolate* isolate,
                                                           uint16_t c1,
                                                           uint16_t c2) {
@@ -496,6 +508,7 @@ static inline Handle<String> MakeOrFindTwoCharacterString(Isolate* isolate,
     return str;
   }
 }
+*/
 
 
 template<typename SinkChar, typename StringType>
@@ -510,6 +523,57 @@ Handle<String> ConcatStringContent(Handle<StringType> result,
 }
 
 
+// This potentially triggers GC.
+static void UpdateConsStringTaintedBytes(Isolate *isolate,
+                                          Handle<String> result,
+                                          Handle<String> str1,
+                                          Handle<String> str2) {
+  // Here we just pretend obj1 and str1 are the same (i.e., no coercion
+  // was done for the string add). Same thing for obj2 and str2.
+  bool tainted1 = isolate->IsV8ObjectTainted(str1);
+  bool tainted2 = isolate->IsV8ObjectTainted(str2);
+  if (tainted1 || tainted2) {
+    std::vector<bool> *ptb1 = isolate->GetStringTaintedBytes(str1);
+    std::vector<bool> *ptb2 = isolate->GetStringTaintedBytes(str2);
+    if (!(tainted1 && tainted2 && ptb1 == NULL && ptb2 == NULL)) {
+      // We need to construct an explicit taint bytes array for the new string.
+      std::vector<bool> tainted_bytes;
+
+      if (tainted1) {
+        if (ptb1 == NULL) {
+          for (int i = 0; i < str1->length(); i++)
+            tainted_bytes.push_back(true);
+        } else {
+          CHECK(str1->length() == ptb1->size());
+          for (int i = 0; i < ptb1->size(); i++)
+            tainted_bytes.push_back(ptb1->at(i));
+        }
+      } else {
+        for (int i = 0; i < str1->length(); i++)
+          tainted_bytes.push_back(false);
+      }
+
+      if (tainted2) {
+        if (ptb2 == NULL) {
+          for (int i = 0; i < str2->length(); i++)
+            tainted_bytes.push_back(true);
+        } else {
+          CHECK(str2->length() == ptb2->size());
+          for (int i = 0; i < ptb2->size(); i++)
+            tainted_bytes.push_back(ptb2->at(i));
+        }
+      } else {
+        for (int i = 0; i < str2->length(); i++)
+          tainted_bytes.push_back(false);
+      }
+
+      CHECK_EQ(result->length(), tainted_bytes.size());
+      isolate->SetTaintForV8Object(result, tainted_bytes);
+    }
+  }
+}
+
+
 MaybeHandle<String> Factory::NewConsString(Handle<String> left,
                                            Handle<String> right) {
   int left_length = left->length();
@@ -519,11 +583,14 @@ MaybeHandle<String> Factory::NewConsString(Handle<String> left,
 
   int length = left_length + right_length;
 
+  // Below is pointless since we disabled two-character string cache.
+  /*
   if (length == 2) {
     uint16_t c1 = left->Get(0);
     uint16_t c2 = right->Get(0);
     return MakeOrFindTwoCharacterString(isolate(), c1, c2);
   }
+  */
 
   // Make sure that an out of memory exception is thrown if the length
   // of the new cons string is too large.
@@ -557,27 +624,32 @@ MaybeHandle<String> Factory::NewConsString(Handle<String> left,
     if (is_one_byte) {
       Handle<SeqOneByteString> result =
           NewRawOneByteString(length).ToHandleChecked();
-      DisallowHeapAllocation no_gc;
-      uint8_t* dest = result->GetChars();
-      // Copy left part.
-      const uint8_t* src =
-          left->IsExternalString()
-              ? Handle<ExternalOneByteString>::cast(left)->GetChars()
-              : Handle<SeqOneByteString>::cast(left)->GetChars();
-      for (int i = 0; i < left_length; i++) *dest++ = src[i];
-      // Copy right part.
-      src = right->IsExternalString()
-                ? Handle<ExternalOneByteString>::cast(right)->GetChars()
-                : Handle<SeqOneByteString>::cast(right)->GetChars();
-      for (int i = 0; i < right_length; i++) *dest++ = src[i];
+      {
+        DisallowHeapAllocation no_gc;
+        uint8_t* dest = result->GetChars();
+        // Copy left part.
+        const uint8_t* src =
+            left->IsExternalString()
+                ? Handle<ExternalOneByteString>::cast(left)->GetChars()
+                : Handle<SeqOneByteString>::cast(left)->GetChars();
+        for (int i = 0; i < left_length; i++) *dest++ = src[i];
+        // Copy right part.
+        src = right->IsExternalString()
+                  ? Handle<ExternalOneByteString>::cast(right)->GetChars()
+                  : Handle<SeqOneByteString>::cast(right)->GetChars();
+        for (int i = 0; i < right_length; i++) *dest++ = src[i];
+      }
+      UpdateConsStringTaintedBytes(isolate(), result, left, right);
       return result;
     }
 
-    return (is_one_byte_data_in_two_byte_string)
+    Handle<String> result = (is_one_byte_data_in_two_byte_string)
         ? ConcatStringContent<uint8_t>(
             NewRawOneByteString(length).ToHandleChecked(), left, right)
         : ConcatStringContent<uc16>(
             NewRawTwoByteString(length).ToHandleChecked(), left, right);
+    UpdateConsStringTaintedBytes(isolate(), result, left, right);
+    return result;
   }
 
   Handle<ConsString> result =
@@ -585,17 +657,51 @@ MaybeHandle<String> Factory::NewConsString(Handle<String> left,
           ? New<ConsString>(cons_one_byte_string_map(), NEW_SPACE)
           : New<ConsString>(cons_string_map(), NEW_SPACE);
 
-  DisallowHeapAllocation no_gc;
-  WriteBarrierMode mode = result->GetWriteBarrierMode(no_gc);
+  {
+    DisallowHeapAllocation no_gc;
+    WriteBarrierMode mode = result->GetWriteBarrierMode(no_gc);
+
+    result->set_hash_field(String::kEmptyHashField);
+    result->set_length(length);
+    result->set_first(*left, mode);
+    result->set_second(*right, mode);
+  }
 
-  result->set_hash_field(String::kEmptyHashField);
-  result->set_length(length);
-  result->set_first(*left, mode);
-  result->set_second(*right, mode);
+  UpdateConsStringTaintedBytes(isolate(), result, left, right);
   return result;
 }
 
 
+// This potentially triggers GC.
+static void UpdateSubStringTaintedBytes(Isolate *isolate,
+                                        std::vector<bool> *tainted_bytes,
+                                        int start,
+                                        int end,
+                                        Handle<String> result) {
+  if (tainted_bytes == NULL)
+    return;
+
+  std::vector<bool> sub_tainted_bytes;
+  bool tainted = false;
+  bool wholly_tainted = true;
+  for (int i = start; i < end; i++) {
+    bool tainted_byte = tainted_bytes->at(i);
+    sub_tainted_bytes.push_back(tainted_byte);
+    if (tainted_byte)
+      tainted = true;
+    else
+      wholly_tainted = false;
+  }
+
+  if (!tainted)
+    isolate->SetDoNotTaint(result);
+  else if (wholly_tainted)
+    isolate->SetTaintForV8Object(result);
+  else
+    isolate->SetTaintForV8Object(result, sub_tainted_bytes);
+}
+
+
 Handle<String> Factory::NewProperSubString(Handle<String> str,
                                            int begin,
                                            int end) {
@@ -604,10 +710,14 @@ Handle<String> Factory::NewProperSubString(Handle<String> str,
 #endif
   DCHECK(begin > 0 || end < str->length());
 
+  std::vector<bool> *tainted_bytes = isolate()->GetStringTaintedBytes(str);
   str = String::Flatten(str);
 
   int length = end - begin;
   if (length <= 0) return empty_string();
+
+  // Below is pointless since we disabled one/two-character string cache.
+  /*
   if (length == 1) {
     return LookupSingleCharacterStringFromCode(str->Get(begin));
   }
@@ -619,21 +729,28 @@ Handle<String> Factory::NewProperSubString(Handle<String> str,
     uint16_t c2 = str->Get(begin + 1);
     return MakeOrFindTwoCharacterString(isolate(), c1, c2);
   }
+  */
 
   if (!FLAG_string_slices || length < SlicedString::kMinLength) {
     if (str->IsOneByteRepresentation()) {
       Handle<SeqOneByteString> result =
           NewRawOneByteString(length).ToHandleChecked();
       uint8_t* dest = result->GetChars();
-      DisallowHeapAllocation no_gc;
-      String::WriteToFlat(*str, dest, begin, end);
+      {
+        DisallowHeapAllocation no_gc;
+        String::WriteToFlat(*str, dest, begin, end);
+      }
+      UpdateSubStringTaintedBytes(isolate(), tainted_bytes, begin, end, result);
       return result;
     } else {
       Handle<SeqTwoByteString> result =
           NewRawTwoByteString(length).ToHandleChecked();
       uc16* dest = result->GetChars();
-      DisallowHeapAllocation no_gc;
-      String::WriteToFlat(*str, dest, begin, end);
+      {
+        DisallowHeapAllocation no_gc;
+        String::WriteToFlat(*str, dest, begin, end);
+      }
+      UpdateSubStringTaintedBytes(isolate(), tainted_bytes, begin, end, result);
       return result;
     }
   }
@@ -656,6 +773,7 @@ Handle<String> Factory::NewProperSubString(Handle<String> str,
   slice->set_length(length);
   slice->set_parent(*str);
   slice->set_offset(offset);
+  UpdateSubStringTaintedBytes(isolate(), tainted_bytes, begin, end, slice);
   return slice;
 }
 
diff --git a/src/flag-definitions.h b/src/flag-definitions.h
index e5ddbadd2c..0044220987 100644
--- a/src/flag-definitions.h
+++ b/src/flag-definitions.h
@@ -321,7 +321,7 @@ DEFINE_STRING(trace_ignition_dispatches_output_file, nullptr,
               "written (by default, the table is not written to a file)")
 
 // Flags for Crankshaft.
-DEFINE_BOOL(crankshaft, true, "use crankshaft")
+DEFINE_BOOL(crankshaft, false, "use crankshaft")
 DEFINE_STRING(hydrogen_filter, "*", "optimization filter")
 DEFINE_BOOL(use_gvn, true, "use hydrogen global value numbering")
 DEFINE_INT(gvn_iterations, 3, "maximum number of GVN fix-point iterations")
@@ -735,7 +735,7 @@ DEFINE_BOOL(trace_code_flushing, false, "trace code flushing progress")
 DEFINE_BOOL(age_code, true,
             "track un-executed functions to age code and flush only "
             "old code (required for code flushing)")
-DEFINE_BOOL(incremental_marking, true, "use incremental marking")
+DEFINE_BOOL(incremental_marking, false, "use incremental marking")
 DEFINE_BOOL(incremental_marking_wrappers, true,
             "use incremental marking for marking wrappers")
 DEFINE_INT(min_progress_during_incremental_marking_finalization, 32,
diff --git a/src/frames-inl.h b/src/frames-inl.h
index 77784b8234..7edd57616b 100644
--- a/src/frames-inl.h
+++ b/src/frames-inl.h
@@ -181,7 +181,7 @@ inline JavaScriptFrame::JavaScriptFrame(StackFrameIteratorBase* iterator)
 
 Address JavaScriptFrame::GetParameterSlot(int index) const {
   int param_count = ComputeParametersCount();
-  DCHECK(-1 <= index && index < param_count);
+  //DCHECK(-1 <= index && index < param_count);
   int parameter_offset = (param_count - index - 1) * kPointerSize;
   return caller_sp() + parameter_offset;
 }
diff --git a/src/full-codegen/full-codegen.cc b/src/full-codegen/full-codegen.cc
index d83a23b3f8..1253179c3f 100644
--- a/src/full-codegen/full-codegen.cc
+++ b/src/full-codegen/full-codegen.cc
@@ -376,6 +376,31 @@ void FullCodeGenerator::TestContext::PrepareTest(
 }
 
 
+void FullCodeGenerator::AccumulatorValueContext::CopyPluggedToScratchRegister()
+    const {
+  __ Move(scratch_register(), result_register());
+}
+
+
+void FullCodeGenerator::StackValueContext::CopyPluggedToScratchRegister()
+    const {
+  __ Pop(scratch_register());
+  __ Push(scratch_register());
+}
+
+
+// Don't care.
+void FullCodeGenerator::TestContext::CopyPluggedToScratchRegister() const {
+  __ Move(scratch_register(), isolate()->factory()->the_hole_value());
+}
+
+
+// Don't care.
+void FullCodeGenerator::EffectContext::CopyPluggedToScratchRegister() const {
+  __ Move(scratch_register(), isolate()->factory()->the_hole_value());
+}
+
+
 void FullCodeGenerator::DoTest(const TestContext* context) {
   DoTest(context->condition(),
          context->true_label(),
@@ -808,6 +833,17 @@ void FullCodeGenerator::VisitProperty(Property* expr) {
     }
   }
   PrepareForBailoutForId(expr->LoadId(), BailoutState::TOS_REGISTER);
+
+  __ Push(result_register());
+
+  PushOperand(Smi::FromInt(0));
+  PushOperand(result_register());
+  PushOperand(Smi::FromInt(scope()->start_position()));
+  PushOperand(Smi::FromInt(expr->position()));
+  CallRuntimeWithOperands(Runtime::kTaintAnalysis_OnVisitProperty);
+
+  __ Pop(result_register());
+
   context()->Plug(result_register());
 }
 
@@ -1058,6 +1094,23 @@ void FullCodeGenerator::VisitReturnStatement(ReturnStatement* stmt) {
   SetStatementPosition(stmt);
   Expression* expr = stmt->expression();
   VisitForAccumulatorValue(expr);
+
+  {
+    Label replace_smi_done;
+    __ JumpIfNotSmi(result_register(), &replace_smi_done);
+    PushOperand(result_register());
+    CallRuntimeWithOperands(Runtime::kTaintAnalysis_ReplaceSmiResult);
+    __ bind(&replace_smi_done);
+  }
+
+  __ Push(result_register());
+
+  PushOperand(result_register());
+  PushOperand(Smi::FromInt(stmt->position()));
+  CallRuntimeWithOperands(Runtime::kTaintAnalysis_OnVisitReturnStatement);
+
+  __ Pop(result_register());
+
   EmitUnwindAndReturn();
 }
 
@@ -1071,6 +1124,12 @@ void FullCodeGenerator::VisitWithStatement(WithStatement* stmt) {
   __ Move(callable.descriptor().GetRegisterParameter(0), result_register());
   __ Call(callable.code(), RelocInfo::CODE_TARGET);
   RestoreContext();
+
+  __ Push(result_register());
+  PushOperand(Smi::FromInt(scope()->start_position()));
+  CallRuntimeWithOperands(Runtime::kTaintAnalysis_OnScopeExit);
+  __ Pop(result_register());
+
   PrepareForBailoutForId(stmt->ToObjectId(), BailoutState::TOS_REGISTER);
   PushOperand(result_register());
   PushFunctionArgumentForContextAllocation();
@@ -1080,9 +1139,14 @@ void FullCodeGenerator::VisitWithStatement(WithStatement* stmt) {
 
   Scope* saved_scope = scope();
   scope_ = stmt->scope();
+
   { WithOrCatch body(this);
     Visit(stmt->statement());
   }
+
+  PushOperand(Smi::FromInt(scope_->start_position()));
+  CallRuntimeWithOperands(Runtime::kTaintAnalysis_OnScopeExit);
+
   scope_ = saved_scope;
 
   // Pop context.
@@ -1269,6 +1333,11 @@ void FullCodeGenerator::VisitTryCatchStatement(TryCatchStatement* stmt) {
   __ bind(&handler_entry);
   if (stmt->clear_pending_message()) ClearPendingMessage();
 
+  __ Push(result_register());
+  PushOperand(Smi::FromInt(scope()->start_position()));
+  CallRuntimeWithOperands(Runtime::kTaintAnalysis_OnScopeExit);
+  __ Pop(result_register());
+
   // Exception handler code, the exception is in the result register.
   // Extend the context before executing the catch block.
   { Comment cmnt(masm_, "[ Extend catch context");
@@ -1282,14 +1351,20 @@ void FullCodeGenerator::VisitTryCatchStatement(TryCatchStatement* stmt) {
 
   Scope* saved_scope = scope();
   scope_ = stmt->scope();
+
   DCHECK(scope_->declarations()->is_empty());
   { WithOrCatch catch_body(this);
     Visit(stmt->catch_block());
   }
+
+  PushOperand(Smi::FromInt(scope_->start_position()));
+  CallRuntimeWithOperands(Runtime::kTaintAnalysis_OnScopeExit);
+
   // Restore the context.
   LoadContextField(context_register(), Context::PREVIOUS_INDEX);
   StoreToFrameField(StandardFrameConstants::kContextOffset, context_register());
   scope_ = saved_scope;
+
   __ jmp(&exit);
 
   // Try block code. Sets up the exception handler chain.
@@ -1479,7 +1554,7 @@ void FullCodeGenerator::VisitClassLiteral(ClassLiteral* lit) {
   CallRuntimeWithOperands(Runtime::kToFastProperties);
 
   if (lit->class_variable_proxy() != nullptr) {
-    EmitVariableAssignment(lit->class_variable_proxy()->var(), Token::INIT,
+    EmitVariableAssignment(lit->class_variable_proxy(), Token::INIT,
                            lit->ProxySlot());
   }
 
@@ -1566,6 +1641,86 @@ void FullCodeGenerator::VisitCall(Call* expr) {
   Expression* callee = expr->expression();
   Call::CallType call_type = expr->GetCallType();
 
+  if (expr->expression()->IsProperty()) {
+    Property *property = expr->expression()->AsProperty();
+    Expression *obj = property->obj();
+    Expression *key = property->key();
+    if (key->IsPropertyName()) {
+      Handle<String> property_name = key->AsLiteral()->AsPropertyName();
+      if (HandleStringEquals(property_name, "setTaint") ) {
+        VisitForStackValue(obj);
+        PushOperand(Smi::FromInt(expr->position()));
+        CallRuntimeWithOperands(Runtime::kTaintAnalysis_SetTaint);
+        context()->Plug(result_register());
+        return;
+      } else if (HandleStringEquals(property_name, "setAsTaintSource")) {
+        VisitForStackValue(obj);
+        VisitForStackValue(expr->arguments()->at(0));
+        CallRuntimeWithOperands(Runtime::kTaintAnalysis_SetAsTaintSource);
+        context()->Plug(result_register());
+        return;
+      } else if (HandleStringEquals(property_name, "isTainted")) {
+        VisitForStackValue(obj);
+        PushOperand(Smi::FromInt(scope()->start_position()));
+        PushOperand(Smi::FromInt(expr->position()));
+        CallRuntimeWithOperands(Runtime::kTaintAnalysis_IsTainted);
+        context()->Plug(result_register());
+        return;
+      } else if (HandleStringEquals(property_name, "resetTaint")) {
+        VisitForStackValue(obj);
+        PushOperand(Smi::FromInt(obj->position()));
+        PushOperand(Smi::FromInt(obj->node_type()));
+        CallRuntimeWithOperands(Runtime::kTaintAnalysis_ResetTaint);
+        context()->Plug(result_register());
+        return;
+      } else if (HandleStringEquals(property_name, "markAsTaintSource")) {
+        VisitForStackValue(obj);
+        CallRuntimeWithOperands(Runtime::kTaintAnalysis_MarkAsTaintSource);
+        context()->Plug(result_register());
+        return;
+      } else if (HandleStringEquals(property_name, "printIsTainted")) {
+        VisitForStackValue(obj);
+        PushOperand(Smi::FromInt(scope()->start_position()));
+        CallRuntimeWithOperands(Runtime::kTaintAnalysis_PrintIsTainted);
+        context()->Plug(result_register());
+        return;
+      } else if (HandleStringEquals(property_name, "doNotPropagate")) {
+        VisitForStackValue(obj);
+        CallRuntimeWithOperands(Runtime::kTaintAnalysis_DoNotPropagate);
+        context()->Plug(result_register());
+        return;
+      } else if (HandleStringEquals(property_name, "getPropagationPaths")) {
+        VisitForStackValue(obj);
+        CallRuntimeWithOperands(Runtime::kTaintAnalysis_GetPropagationPaths);
+        context()->Plug(result_register());
+        return;
+      } else if (HandleStringEquals(property_name, "logTaintSink")) {
+        VisitForStackValue(obj);
+        VisitForStackValue(expr->arguments()->at(0));
+        VisitForStackValue(expr->arguments()->at(1));
+        CallRuntimeWithOperands(Runtime::kTaintAnalysis_LogTaintSink);
+        context()->Plug(result_register());
+        return;
+      } else if (HandleStringEquals(property_name, "isAstNodeTainted")) {
+        VisitForStackValue(obj);
+        __ Pop(scratch_register());
+        __ Push(scratch_register());
+        __ Push(scratch_register());
+        PushOperand(Smi::FromInt(obj->position()));
+        PushOperand(Smi::FromInt(obj->node_type()));
+        CallRuntimeWithOperands(Runtime::kTaintAnalysis_IsAstNodeTainted);
+        __ Pop(scratch_register());
+        context()->Plug(scratch_register());
+        return;
+      } else if (HandleStringEquals(property_name, "isHeapNumber")) {
+        VisitForStackValue(obj);
+        CallRuntimeWithOperands(Runtime::kTaintAnalysis_IsHeapNumber);
+        context()->Plug(result_register());
+        return;
+      }
+    }
+  }
+
   switch (call_type) {
     case Call::POSSIBLY_EVAL_CALL:
       EmitPossiblyEvalCall(expr);
@@ -1581,22 +1736,54 @@ void FullCodeGenerator::VisitCall(Call* expr) {
     case Call::NAMED_PROPERTY_CALL: {
       Property* property = callee->AsProperty();
       VisitForStackValue(property->obj());
+
+      __ Pop(scratch_register());
+      __ Push(scratch_register());
+      PushOperand(scratch_register());
+      PushOperand(Smi::FromInt(0));  // Don't care.
+      PushOperand(Smi::FromInt(scope()->start_position()));
+      PushOperand(Smi::FromInt(property->position()));
+      CallRuntimeWithOperands(Runtime::kTaintAnalysis_OnVisitProperty);
+
       EmitCallWithLoadIC(expr);
       break;
     }
     case Call::KEYED_PROPERTY_CALL: {
       Property* property = callee->AsProperty();
       VisitForStackValue(property->obj());
+
+      __ Pop(scratch_register());
+      __ Push(scratch_register());
+      PushOperand(scratch_register());
+      PushOperand(Smi::FromInt(0));  // Don't care.
+      PushOperand(Smi::FromInt(scope()->start_position()));
+      PushOperand(Smi::FromInt(property->position()));
+      CallRuntimeWithOperands(Runtime::kTaintAnalysis_OnVisitProperty);
+
       EmitKeyedCallWithLoadIC(expr, property->key());
       break;
     }
-    case Call::NAMED_SUPER_PROPERTY_CALL:
+    case Call::NAMED_SUPER_PROPERTY_CALL: {
+      Property *property = callee->AsProperty();
+      VisitForStackValue(property->obj());
+      PushOperand(Smi::FromInt(0));  // Don't care.
+      PushOperand(Smi::FromInt(scope()->start_position()));
+      PushOperand(Smi::FromInt(property->position()));
+      CallRuntimeWithOperands(Runtime::kTaintAnalysis_OnVisitProperty);
+
       EmitSuperCallWithLoadIC(expr);
       break;
-    case Call::KEYED_SUPER_PROPERTY_CALL:
+    } case Call::KEYED_SUPER_PROPERTY_CALL: {
+      Property *property = callee->AsProperty();
+      VisitForStackValue(property->obj());
+      PushOperand(Smi::FromInt(0));  // Don't care.
+      PushOperand(Smi::FromInt(scope()->start_position()));
+      PushOperand(Smi::FromInt(property->position()));
+      CallRuntimeWithOperands(Runtime::kTaintAnalysis_OnVisitProperty);
+
       EmitKeyedSuperCallWithLoadIC(expr);
       break;
-    case Call::SUPER_CALL:
+    } case Call::SUPER_CALL:
       EmitSuperConstructorCall(expr);
       break;
     case Call::OTHER_CALL:
@@ -1609,6 +1796,23 @@ void FullCodeGenerator::VisitCall(Call* expr) {
       break;
   }
 
+  {
+    Label invalid_context;
+
+    context()->CopyPluggedToScratchRegister();  // This needs to come first.
+    __ Push(result_register());
+    __ Move(result_register(), isolate()->factory()->the_hole_value());
+    __ cmpp(scratch_register(), result_register());
+    __ j(equal, &invalid_context);
+
+    PushOperand(scratch_register());
+    PushOperand(Smi::FromInt(expr->position()));
+    CallRuntimeWithOperands(Runtime::kTaintAnalysis_OnReturnFromCall);
+
+    __ bind(&invalid_context);
+    __ Pop(result_register());
+  }
+
 #ifdef DEBUG
   // RecordJSReturnSite should have been called.
   DCHECK(expr->return_is_recorded_);
@@ -1647,6 +1851,23 @@ void FullCodeGenerator::VisitCallRuntime(CallRuntime* expr) {
         // Push the arguments ("left-to-right").
         for (int i = 0; i < arg_count; i++) {
           VisitForStackValue(args->at(i));
+          if (i == 2 &&
+              function->function_id == Runtime::kInitializeVarGlobal) {
+            {
+              Label replace_smi_done;
+              __ Pop(result_register());
+              __ JumpIfNotSmi(result_register(), &replace_smi_done);
+              PushOperand(result_register());
+              CallRuntimeWithOperands(Runtime::kTaintAnalysis_ReplaceSmiResult);
+              __ bind(&replace_smi_done);
+              __ Push(result_register());
+            }
+
+            PushOperand(result_register());
+            PushOperand(Smi::FromInt(expr->position()));
+            CallRuntimeWithOperands(
+                Runtime::kTaintAnalysis_OnTopLevelVarInitialization);
+          }
         }
 
         // Call the C runtime function.
@@ -1844,6 +2065,10 @@ FullCodeGenerator::EnterBlockScopeIfNeeded::EnterBlockScopeIfNeeded(
   } else {
     needs_block_context_ = scope->NeedsContext();
     codegen_->scope_ = scope;
+
+    codegen_->PushOperand(Smi::FromInt(saved_scope_->start_position()));
+    codegen_->CallRuntimeWithOperands(Runtime::kTaintAnalysis_OnScopeExit);
+
     {
       if (needs_block_context_) {
         Comment cmnt(masm(), "[ Extend block context");
@@ -1858,6 +2083,7 @@ FullCodeGenerator::EnterBlockScopeIfNeeded::EnterBlockScopeIfNeeded(
       CHECK_EQ(0, scope->num_stack_slots());
       codegen_->PrepareForBailoutForId(entry_id, BailoutState::NO_REGISTERS);
     }
+
     {
       Comment cmnt(masm(), "[ Declarations");
       codegen_->VisitDeclarations(scope->declarations());
@@ -1869,6 +2095,11 @@ FullCodeGenerator::EnterBlockScopeIfNeeded::EnterBlockScopeIfNeeded(
 
 
 FullCodeGenerator::EnterBlockScopeIfNeeded::~EnterBlockScopeIfNeeded() {
+  if (codegen_->scope() != saved_scope_) {
+    codegen_->PushOperand(Smi::FromInt(codegen_->scope()->start_position()));
+    codegen_->CallRuntimeWithOperands(Runtime::kTaintAnalysis_OnScopeExit);
+  }
+
   if (needs_block_context_) {
     codegen_->LoadContextField(codegen_->context_register(),
                                Context::PREVIOUS_INDEX);
diff --git a/src/full-codegen/full-codegen.h b/src/full-codegen/full-codegen.h
index 71f065b092..b6bfe65612 100644
--- a/src/full-codegen/full-codegen.h
+++ b/src/full-codegen/full-codegen.h
@@ -592,7 +592,11 @@ class FullCodeGenerator final : public AstVisitor<FullCodeGenerator> {
 
   // Complete a variable assignment.  The right-hand-side value is expected
   // in the accumulator.
-  void EmitVariableAssignment(Variable* var, Token::Value op,
+  //
+  // HACK: This old interface is stupid anyway.
+  //void EmitVariableAssignment(Variable* var, Token::Value op,
+  //                            FeedbackVectorSlot slot);
+  void EmitVariableAssignment(VariableProxy* proxy, Token::Value op,
                               FeedbackVectorSlot slot);
 
   // Helper functions to EmitVariableAssignment
@@ -703,6 +707,8 @@ class FullCodeGenerator final : public AstVisitor<FullCodeGenerator> {
 
   static Register context_register();
 
+  static Register scratch_register();  // x64
+
   // Get fields from the stack frame. Offsets are the frame pointer relative
   // offsets defined in, e.g., StandardFrameConstants.
   void LoadFromFrameField(int frame_offset, Register value);
@@ -818,6 +824,8 @@ class FullCodeGenerator final : public AstVisitor<FullCodeGenerator> {
     // it.  Only used for asserts.
     virtual bool IsTest() const { return false; }
 
+    virtual void CopyPluggedToScratchRegister() const = 0;
+
    protected:
     FullCodeGenerator* codegen() const { return codegen_; }
     MacroAssembler* masm() const { return masm_; }
@@ -845,6 +853,8 @@ class FullCodeGenerator final : public AstVisitor<FullCodeGenerator> {
                      Label** if_true, Label** if_false,
                      Label** fall_through) const override;
     bool IsAccumulatorValue() const override { return true; }
+
+    void CopyPluggedToScratchRegister() const override;
   };
 
   class StackValueContext : public ExpressionContext {
@@ -864,6 +874,8 @@ class FullCodeGenerator final : public AstVisitor<FullCodeGenerator> {
                      Label** if_true, Label** if_false,
                      Label** fall_through) const override;
     bool IsStackValue() const override { return true; }
+
+    void CopyPluggedToScratchRegister() const override;
   };
 
   class TestContext : public ExpressionContext {
@@ -902,6 +914,8 @@ class FullCodeGenerator final : public AstVisitor<FullCodeGenerator> {
                      Label** fall_through) const override;
     bool IsTest() const override { return true; }
 
+    void CopyPluggedToScratchRegister() const override;
+
    private:
     Expression* condition_;
     Label* true_label_;
@@ -926,6 +940,8 @@ class FullCodeGenerator final : public AstVisitor<FullCodeGenerator> {
                      Label** if_true, Label** if_false,
                      Label** fall_through) const override;
     bool IsEffect() const override { return true; }
+
+    void CopyPluggedToScratchRegister() const override;
   };
 
   class EnterBlockScopeIfNeeded {
diff --git a/src/full-codegen/x64/full-codegen-x64.cc b/src/full-codegen/x64/full-codegen-x64.cc
index 4b0e43c9b2..fd5667b601 100644
--- a/src/full-codegen/x64/full-codegen-x64.cc
+++ b/src/full-codegen/x64/full-codegen-x64.cc
@@ -313,6 +313,7 @@ void FullCodeGenerator::Generate() {
   {
     Comment cmnt(masm_, "[ Body");
     DCHECK(loop_depth() == 0);
+    __ CallRuntime(Runtime::kTaintAnalysis_OnFunctionEnter);
     VisitStatements(literal()->body());
     DCHECK(loop_depth() == 0);
   }
@@ -413,6 +414,14 @@ void FullCodeGenerator::EmitReturnSequence() {
     __ jmp(&return_label_);
   } else {
     __ bind(&return_label_);
+
+    __ Push(rax);
+
+    PushOperand(Smi::FromInt(scope()->start_position()));
+    CallRuntimeWithOperands(Runtime::kTaintAnalysis_OnScopeExit);
+
+    __ Pop(rax);
+
     if (FLAG_trace) {
       __ Push(rax);
       __ CallRuntime(Runtime::kTraceExit);
@@ -1289,6 +1298,24 @@ void FullCodeGenerator::EmitVariableLoad(VariableProxy* proxy,
     case VariableLocation::MODULE:
       UNREACHABLE();
   }
+
+  {
+    Label invalid_context;
+
+    context()->CopyPluggedToScratchRegister();  // This needs to come first.
+    __ Push(result_register());
+    __ Move(result_register(), isolate()->factory()->the_hole_value());
+    __ cmpp(scratch_register(), result_register());
+    __ j(equal, &invalid_context);
+
+    PushOperand(scratch_register());
+    PushOperand(Smi::FromInt(scope()->start_position()));
+    PushOperand(Smi::FromInt(proxy->position()));
+    CallRuntimeWithOperands(Runtime::kTaintAnalysis_OnVisitVariableProxy);
+
+    __ bind(&invalid_context);
+    __ Pop(result_register());
+  }
 }
 
 
@@ -1340,7 +1367,23 @@ void FullCodeGenerator::VisitObjectLiteral(ObjectLiteral* expr) {
   for (; property_index < expr->properties()->length(); property_index++) {
     ObjectLiteral::Property* property = expr->properties()->at(property_index);
     if (property->is_computed_name()) break;
-    if (property->IsCompileTimeValue()) continue;
+
+    if (property->IsCompileTimeValue()) {
+      __ Push(rax);
+
+      // If it's compile time value, then it's probably constant that's
+      // handled in the ObjectLiteral creation code above. For now
+      // we don't replace such values if they are Smi, since constants are
+      // probably (?) not tainted in the first place.
+      VisitForStackValue(property->value());
+      PushOperand(Smi::FromInt(scope()->start_position()));
+      PushOperand(Smi::FromInt(expr->position()));
+      PushOperand(Smi::FromInt(property_index));
+      CallRuntimeWithOperands(Runtime::kTaintAnalysis_OnVisitObjectLiteral);
+
+      __ Pop(rax);
+      continue;
+    }
 
     Literal* key = property->key()->AsLiteral();
     Expression* value = property->value();
@@ -1359,8 +1402,24 @@ void FullCodeGenerator::VisitObjectLiteral(ObjectLiteral* expr) {
         // contains computed properties with an uninitialized value.
         if (key->IsStringLiteral()) {
           DCHECK(key->IsPropertyName());
+
+          VisitForAccumulatorValue(value);
+          {
+            Label replace_smi_done;
+            __ JumpIfNotSmi(result_register(), &replace_smi_done);
+            PushOperand(result_register());
+            CallRuntimeWithOperands(Runtime::kTaintAnalysis_ReplaceSmiResult);
+            __ bind(&replace_smi_done);
+          }
+          __ Push(rax);
+          PushOperand(rax);
+          PushOperand(Smi::FromInt(scope()->start_position()));
+          PushOperand(Smi::FromInt(expr->position()));
+          PushOperand(Smi::FromInt(property_index));
+          CallRuntimeWithOperands(Runtime::kTaintAnalysis_OnVisitObjectLiteral);
+          __ Pop(rax);
+
           if (property->emit_store()) {
-            VisitForAccumulatorValue(value);
             DCHECK(StoreDescriptor::ValueRegister().is(rax));
             __ Move(StoreDescriptor::NameRegister(), key->value());
             __ movp(StoreDescriptor::ReceiverRegister(), Operand(rsp, 0));
@@ -1371,14 +1430,27 @@ void FullCodeGenerator::VisitObjectLiteral(ObjectLiteral* expr) {
             if (NeedsHomeObject(value)) {
               EmitSetHomeObjectAccumulator(value, 0, property->GetSlot(1));
             }
-          } else {
-            VisitForEffect(value);
           }
           break;
         }
         PushOperand(Operand(rsp, 0));  // Duplicate receiver.
         VisitForStackValue(key);
-        VisitForStackValue(value);
+        VisitForAccumulatorValue(value);
+        {
+          Label replace_smi_done;
+          __ JumpIfNotSmi(result_register(), &replace_smi_done);
+          PushOperand(result_register());
+          CallRuntimeWithOperands(Runtime::kTaintAnalysis_ReplaceSmiResult);
+          __ bind(&replace_smi_done);
+        }
+        PushOperand(result_register());
+
+        PushOperand(result_register());
+        PushOperand(Smi::FromInt(scope()->start_position()));
+        PushOperand(Smi::FromInt(expr->position()));
+        PushOperand(Smi::FromInt(property_index));
+        CallRuntimeWithOperands(Runtime::kTaintAnalysis_OnVisitObjectLiteral);
+
         if (property->emit_store()) {
           if (NeedsHomeObject(value)) {
             EmitSetHomeObject(value, 2, property->GetSlot());
@@ -1457,7 +1529,26 @@ void FullCodeGenerator::VisitObjectLiteral(ObjectLiteral* expr) {
                              BailoutState::NO_REGISTERS);
     } else {
       EmitPropertyKey(property, expr->GetIdForPropertyName(property_index));
-      VisitForStackValue(value);
+      VisitForAccumulatorValue(value);
+      {
+        Label replace_smi_done;
+        __ JumpIfNotSmi(result_register(), &replace_smi_done);
+        PushOperand(result_register());
+        CallRuntimeWithOperands(Runtime::kTaintAnalysis_ReplaceSmiResult);
+        __ bind(&replace_smi_done);
+      }
+      PushOperand(result_register());
+
+      if (property->kind() == ObjectLiteral::Property::CONSTANT ||
+          property->kind() == ObjectLiteral::Property::COMPUTED ||
+          property->kind() == ObjectLiteral::Property::MATERIALIZED_LITERAL) {
+        PushOperand(result_register());
+        PushOperand(Smi::FromInt(scope()->start_position()));
+        PushOperand(Smi::FromInt(expr->position()));
+        PushOperand(Smi::FromInt(property_index));
+        CallRuntimeWithOperands(Runtime::kTaintAnalysis_OnVisitObjectLiteral);
+      }
+
       if (NeedsHomeObject(value)) {
         EmitSetHomeObject(value, 2, property->GetSlot());
       }
@@ -1544,6 +1635,9 @@ void FullCodeGenerator::VisitArrayLiteral(ArrayLiteral* expr) {
 
     // If the subexpression is a literal or a simple materialized literal it
     // is already set in the cloned array.
+    //
+    // Same thing as ObjectLiteral here, we don't bother to replace Smi
+    // constants with HeapNumber.
     if (CompileTimeValue::IsCompileTimeValue(subexpr)) continue;
 
     if (!result_saved) {
@@ -1551,18 +1645,65 @@ void FullCodeGenerator::VisitArrayLiteral(ArrayLiteral* expr) {
       result_saved = true;
     }
     VisitForAccumulatorValue(subexpr);
+    {
+      Label replace_smi_done;
+      __ JumpIfNotSmi(result_register(), &replace_smi_done);
+      /*
+      PushOperand(result_register());
+      CallRuntimeWithOperands(Runtime::kTaintAnalysis_ReplaceSmiResult2);
+      */
+      __ bind(&replace_smi_done);
+    }
+
+    {
+      __ Pop(scratch_register());
+      __ Push(scratch_register());
+      PushOperand(scratch_register());  // Receiver.
+
+      __ Push(result_register());
+      __ Move(result_register(), Smi::FromInt(array_index));
+      Handle<Code> ic = CodeFactory::ToString(isolate()).code();
+      CallIC(ic);
+      __ Pop(scratch_register());  // result_register() = name
+                                   // scratch_register() = value
 
+      PushOperand(result_register());
+      PushOperand(scratch_register());
+      PushOperand(Smi::FromInt(NONE));
+      PushOperand(Smi::FromInt(0));
+      CallRuntimeWithOperands(Runtime::kDefineDataPropertyInLiteral);
+    }
+
+    /*
     __ Move(StoreDescriptor::NameRegister(), Smi::FromInt(array_index));
     __ movp(StoreDescriptor::ReceiverRegister(), Operand(rsp, 0));
     EmitLoadStoreICSlot(expr->LiteralFeedbackSlot());
     Handle<Code> ic =
         CodeFactory::KeyedStoreIC(isolate(), language_mode()).code();
     CallIC(ic);
+    */
 
     PrepareForBailoutForId(expr->GetIdForElement(array_index),
                            BailoutState::NO_REGISTERS);
   }
 
+  if (result_saved)
+    __ movp(rax, Operand(rsp, 0));  // Doesn't matter what rax contains.
+
+  __ Push(rax);
+
+  PushOperand(rax);
+  PushOperand(Smi::FromInt(scope()->start_position()));
+  PushOperand(Smi::FromInt(expr->position()));
+  CallRuntimeWithOperands(Runtime::kTaintAnalysis_OnVisitArrayLiteral);
+
+  __ Pop(rax);
+
+  // CHECK(array_index == length);
+  //
+  // The above check always passes, so ignore all the code
+  // below (except the context()->Plug.*() part of course).
+
   // In case the array literal contains spread expressions it has two parts. The
   // first part is  the "static" array which has a literal index is  handled
   // above. The second part is the part after the first spread expression
@@ -1577,7 +1718,15 @@ void FullCodeGenerator::VisitArrayLiteral(ArrayLiteral* expr) {
 
     PushOperand(rax);
     DCHECK(!subexpr->IsSpread());
-    VisitForStackValue(subexpr);
+    VisitForAccumulatorValue(subexpr);
+    {
+      Label replace_smi_done;
+      __ JumpIfNotSmi(result_register(), &replace_smi_done);
+      PushOperand(result_register());
+      CallRuntimeWithOperands(Runtime::kTaintAnalysis_ReplaceSmiResult);
+      __ bind(&replace_smi_done);
+    }
+    PushOperand(result_register());
     CallRuntimeWithOperands(Runtime::kAppendElement);
 
     PrepareForBailoutForId(expr->GetIdForElement(array_index),
@@ -1703,12 +1852,33 @@ void FullCodeGenerator::VisitAssignment(Assignment* expr) {
     VisitForAccumulatorValue(expr->value());
   }
 
+  // At this point the value being assigned is contained in result_register (?)
+  if (assign_type != VARIABLE) {
+    {
+      Label replace_smi_done;
+      __ JumpIfNotSmi(result_register(), &replace_smi_done);
+      PushOperand(result_register());
+      CallRuntimeWithOperands(Runtime::kTaintAnalysis_ReplaceSmiResult);
+      __ bind(&replace_smi_done);
+    }
+
+    __ Push(result_register());
+
+    PushOperand(Smi::FromInt(0));    // Home object - don't care.
+    PushOperand(result_register());  // Assigned value.
+    PushOperand(Smi::FromInt(scope()->start_position()));
+    PushOperand(Smi::FromInt(property->position()));
+    CallRuntimeWithOperands(Runtime::kTaintAnalysis_OnVisitProperty);
+
+    __ Pop(result_register());
+  }
+
   SetExpressionPosition(expr);
 
   // Store the value.
   switch (assign_type) {
     case VARIABLE:
-      EmitVariableAssignment(expr->target()->AsVariableProxy()->var(),
+      EmitVariableAssignment(expr->target()->AsVariableProxy(),
                              expr->op(), expr->AssignmentSlot());
       PrepareForBailoutForId(expr->AssignmentId(), BailoutState::TOS_REGISTER);
       context()->Plug(rax);
@@ -1959,9 +2129,8 @@ void FullCodeGenerator::EmitAssignment(Expression* expr,
 
   switch (assign_type) {
     case VARIABLE: {
-      Variable* var = expr->AsVariableProxy()->var();
       EffectContext context(this);
-      EmitVariableAssignment(var, Token::ASSIGN, slot);
+      EmitVariableAssignment(expr->AsVariableProxy(), Token::ASSIGN, slot);
       break;
     }
     case NAMED_PROPERTY: {
@@ -2041,8 +2210,18 @@ void FullCodeGenerator::EmitStoreToStackLocalOrContextSlot(
 }
 
 
-void FullCodeGenerator::EmitVariableAssignment(Variable* var, Token::Value op,
+void FullCodeGenerator::EmitVariableAssignment(VariableProxy* proxy,
+                                               Token::Value op,
                                                FeedbackVectorSlot slot) {
+  {
+    Label replace_smi_done;
+    __ JumpIfNotSmi(result_register(), &replace_smi_done);
+    PushOperand(result_register());
+    CallRuntimeWithOperands(Runtime::kTaintAnalysis_ReplaceSmiResult);
+    __ bind(&replace_smi_done);
+  }
+
+  Variable *var = proxy->var();
   if (var->IsUnallocated()) {
     // Global var, const, or let.
     __ Move(StoreDescriptor::NameRegister(), var->name());
@@ -2112,6 +2291,15 @@ void FullCodeGenerator::EmitVariableAssignment(Variable* var, Token::Value op,
     }
     // Silently ignore store in sloppy mode.
   }
+
+  // The value of assignment is in result_register(). Here we don't have
+  // to deal with context plug business.
+  __ Push(result_register());
+  PushOperand(result_register());
+  PushOperand(Smi::FromInt(scope()->start_position()));
+  PushOperand(Smi::FromInt(proxy->position()));
+  CallRuntimeWithOperands(Runtime::kTaintAnalysis_OnVisitVariableProxy);
+  __ Pop(result_register());
 }
 
 
@@ -2319,6 +2507,15 @@ void FullCodeGenerator::EmitCall(Call* expr, ConvertReceiverMode mode) {
     VisitForStackValue(args->at(i));
   }
 
+  __ movp(kScratchRegister, rsp);
+  PushOperand(kScratchRegister);  // Address of the last argument.
+  PushOperand(Smi::FromInt(arg_count));
+  // Callee.
+  PushOperand(Operand(rsp, (arg_count + 3) * kPointerSize));
+  PushOperand(Smi::FromInt(scope()->start_position()));
+  PushOperand(Smi::FromInt(expr->position()));
+  CallRuntimeWithOperands(Runtime::kTaintAnalysis_OnVisitCallArguments);
+
   PrepareForBailoutForId(expr->CallId(), BailoutState::NO_REGISTERS);
   SetCallPosition(expr, expr->tail_call_mode());
   if (expr->tail_call_mode() == TailCallMode::kAllow) {
@@ -2425,6 +2622,15 @@ void FullCodeGenerator::EmitPossiblyEvalCall(Call* expr) {
     VisitForStackValue(args->at(i));
   }
 
+  __ movp(kScratchRegister, rsp);
+  PushOperand(kScratchRegister);  // Address of the last argument.
+  PushOperand(Smi::FromInt(arg_count));
+  // Callee.
+  PushOperand(Operand(rsp, (arg_count + 3) * kPointerSize));
+  PushOperand(Smi::FromInt(scope()->start_position()));
+  PushOperand(Smi::FromInt(expr->position()));
+  CallRuntimeWithOperands(Runtime::kTaintAnalysis_OnVisitCallArguments);
+
   // Push a copy of the function (found below the arguments) and resolve
   // eval.
   __ Push(Operand(rsp, (arg_count + 1) * kPointerSize));
@@ -2508,6 +2714,15 @@ void FullCodeGenerator::EmitSuperConstructorCall(Call* expr) {
     VisitForStackValue(args->at(i));
   }
 
+  __ movp(kScratchRegister, rsp);
+  PushOperand(kScratchRegister);  // Address of the last argument.
+  PushOperand(Smi::FromInt(arg_count));
+  // Callee - note that here it's directly below the arguments.
+  PushOperand(Operand(rsp, (arg_count + 2) * kPointerSize));
+  PushOperand(Smi::FromInt(scope()->start_position()));
+  PushOperand(Smi::FromInt(expr->position()));
+  CallRuntimeWithOperands(Runtime::kTaintAnalysis_OnVisitCallArguments);
+
   // Call the construct call builtin that handles allocation and
   // constructor invocation.
   SetConstructCallPosition(expr);
@@ -3195,7 +3410,7 @@ void FullCodeGenerator::VisitCountOperation(CountOperation* expr) {
       if (expr->is_postfix()) {
         // Perform the assignment as if via '='.
         { EffectContext context(this);
-          EmitVariableAssignment(expr->expression()->AsVariableProxy()->var(),
+          EmitVariableAssignment(expr->expression()->AsVariableProxy(),
                                  Token::ASSIGN, expr->CountSlot());
           PrepareForBailoutForId(expr->AssignmentId(),
                                  BailoutState::TOS_REGISTER);
@@ -3208,7 +3423,7 @@ void FullCodeGenerator::VisitCountOperation(CountOperation* expr) {
         }
       } else {
         // Perform the assignment as if via '='.
-        EmitVariableAssignment(expr->expression()->AsVariableProxy()->var(),
+        EmitVariableAssignment(expr->expression()->AsVariableProxy(),
                                Token::ASSIGN, expr->CountSlot());
         PrepareForBailoutForId(expr->AssignmentId(),
                                BailoutState::TOS_REGISTER);
@@ -3468,6 +3683,11 @@ Register FullCodeGenerator::context_register() {
   return rsi;
 }
 
+
+Register FullCodeGenerator::scratch_register() {
+  return kScratchRegister;
+}
+
 void FullCodeGenerator::LoadFromFrameField(int frame_offset, Register value) {
   DCHECK(IsAligned(frame_offset, kPointerSize));
   __ movp(value, Operand(rbp, frame_offset));
diff --git a/src/handles-inl.h b/src/handles-inl.h
index cfaf4fb6eb..04dc567fbf 100644
--- a/src/handles-inl.h
+++ b/src/handles-inl.h
@@ -97,6 +97,10 @@ Handle<T> HandleScope::CloseAndEscape(Handle<T> handle_value) {
 
 Object** HandleScope::CreateHandle(Isolate* isolate, Object* value) {
   DCHECK(AllowHandleAllocation::IsAllowed());
+
+  if (isolate->InPersistentHandleMode())
+    return isolate->CreatePersistentHandle(value);
+
   HandleScopeData* data = isolate->handle_scope_data();
 
   Object** result = data->next;
@@ -111,8 +115,23 @@ Object** HandleScope::CreateHandle(Isolate* isolate, Object* value) {
 }
 
 
+Object** HandleScope::CreatePersistentHandle(Isolate* isolate, Object* value) {
+  DCHECK(AllowHandleAllocation::IsAllowed());
+
+  CHECK(!isolate->InPersistentHandleMode());
+  isolate->EnterPersistentHandleMode(isolate);
+  Object **ret = isolate->CreatePersistentHandle(value);
+  isolate->ExitPersistentHandleMode();
+  return ret;
+}
+
+
 Object** HandleScope::GetHandle(Isolate* isolate, Object* value) {
   DCHECK(AllowHandleAllocation::IsAllowed());
+
+  if (isolate->InPersistentHandleMode())
+    return isolate->CreatePersistentHandle(value);
+
   HandleScopeData* data = isolate->handle_scope_data();
   CanonicalHandleScope* canonical = data->canonical_scope;
   return canonical ? canonical->Lookup(value) : CreateHandle(isolate, value);
diff --git a/src/handles.h b/src/handles.h
index a7cd0e2497..387a780bf6 100644
--- a/src/handles.h
+++ b/src/handles.h
@@ -270,6 +270,10 @@ class HandleScope {
   // Creates a new handle with the given value.
   V8_INLINE static Object** CreateHandle(Isolate* isolate, Object* value);
 
+  // Same as above but always persistent.
+  V8_INLINE static Object** CreatePersistentHandle(Isolate* isolate,
+                                                   Object* value);
+
   // Deallocates any extensions used by the current scope.
   static void DeleteExtensions(Isolate* isolate);
 
diff --git a/src/heap/heap.cc b/src/heap/heap.cc
index 7eb5af3b6a..5afe0714b0 100644
--- a/src/heap/heap.cc
+++ b/src/heap/heap.cc
@@ -743,6 +743,8 @@ void Heap::GarbageCollectionEpilogue() {
   last_gc_time_ = MonotonicallyIncreasingTimeInMs();
 
   ReduceNewSpaceSize();
+
+  isolate_->PostGCHook();
 }
 
 
@@ -992,7 +994,7 @@ bool Heap::CollectGarbage(GarbageCollector collector, const char* gc_reason,
 
   {
     tracer()->Start(collector, gc_reason, collector_reason);
-    DCHECK(AllowHeapAllocation::IsAllowed());
+    CHECK(AllowHeapAllocation::IsAllowed());
     DisallowHeapAllocation no_allocation_during_gc;
     GarbageCollectionPrologue();
 
@@ -4867,6 +4869,11 @@ void Heap::IterateStrongRoots(ObjectVisitor* v, VisitMode mode) {
   FixStaleLeftTrimmedHandlesVisitor left_trim_visitor(this);
   isolate_->handle_scope_implementer()->Iterate(&left_trim_visitor);
   isolate_->handle_scope_implementer()->Iterate(v);
+  // Taint analysis stuff.
+  if (mode != VISIT_ONLY_STRONG_FOR_SERIALIZATION) {
+    isolate_->IterateTaintAnalysisStuff(&left_trim_visitor);
+    isolate_->IterateTaintAnalysisStuff(v);
+  }
   isolate_->IterateDeferredHandles(v);
   v->Synchronize(VisitorSynchronization::kHandleScope);
 
diff --git a/src/heap/mark-compact.cc b/src/heap/mark-compact.cc
index db3bcff7a1..8f9316c77f 100644
--- a/src/heap/mark-compact.cc
+++ b/src/heap/mark-compact.cc
@@ -2703,6 +2703,14 @@ void MarkCompactCollector::ClearWeakCollections() {
       for (int i = 0; i < table->Capacity(); i++) {
         HeapObject* key = HeapObject::cast(table->KeyAt(i));
         if (!MarkCompactCollector::IsMarked(key)) {
+          if (weak_collection->value_destructor()) {
+            Object** value_slot = table->RawFieldOfElementAt(
+                ObjectHashTable::EntryToValueIndex(i));
+            isolate()->EnqueueValueForDestroy(
+                *value_slot,
+                reinterpret_cast<void (*)(Isolate *, void *)>(
+                    weak_collection->value_destructor()));
+          }
           table->RemoveEntry(i);
         }
       }
diff --git a/src/isolate.cc b/src/isolate.cc
index 624f2a8d93..41a4ad5853 100644
--- a/src/isolate.cc
+++ b/src/isolate.cc
@@ -44,6 +44,10 @@
 #include "src/vm-state-inl.h"
 #include "src/wasm/wasm-module.h"
 
+#include "src/runtime/runtime-taint.h"
+#include <iostream>
+#include <fcntl.h>
+
 namespace v8 {
 namespace internal {
 
@@ -2024,7 +2028,25 @@ Isolate::Isolate(bool enable_serializer)
       use_counter_callback_(NULL),
       basic_block_profiler_(NULL),
       cancelable_task_manager_(new CancelableTaskManager()),
-      abort_on_uncaught_exception_callback_(NULL) {
+      abort_on_uncaught_exception_callback_(NULL),
+      persistent_handle_lookup_(NULL),
+      persistent_handle_data_(NULL),
+      permanent_ast_cache_(NULL),
+      ast_cache_(NULL),
+      hit_count_(0),
+      lookup_count_(0),
+      taint_table_(NULL),
+      do_not_taint_(NULL),
+      extension_contexts_(NULL),
+      tainted_js_functions_(NULL),
+      taint_source_objects_(NULL),
+      taint_sources_(NULL),
+#ifndef DISABLE_PROPAGATION_REPORT
+      propagated_from_(NULL),
+      propagates_to_(NULL),
+#endif
+      do_not_propagate_(NULL),
+      do_not_propagate_functions_(NULL) {
   {
     base::LockGuard<base::Mutex> lock_guard(thread_data_table_mutex_.Pointer());
     CHECK(thread_data_table_);
@@ -2111,6 +2133,25 @@ void Isolate::ClearSerializerData() {
 void Isolate::Deinit() {
   TRACE_ISOLATE(deinit);
 
+  DestroyPersistentHandles(this);
+
+  delete permanent_ast_cache_;
+  delete ast_cache_;
+  delete taint_table_;
+  delete do_not_taint_;
+
+  delete extension_contexts_;
+  delete tainted_js_functions_;
+  delete taint_source_objects_;
+  delete taint_sources_;
+
+#ifndef DISABLE_PROPAGATION_REPORT
+  delete propagated_from_;
+#endif
+
+  delete do_not_propagate_;
+  delete do_not_propagate_functions_;
+
   debug()->Unload();
 
   FreeThreadResources();
@@ -2281,6 +2322,1204 @@ Isolate::~Isolate() {
 }
 
 
+void Isolate::IterateTaintAnalysisStuff(ObjectVisitor *v) {
+  persistent_handle_table_.iterate(PersistentHandleData::IterateHandles, v);
+}
+
+
+void Isolate::PostGCHook() {
+  DestroyQueuedValues();
+}
+
+
+void Isolate::EnterPersistentHandleMode(void *lookup) {
+  CHECK(!InPersistentHandleMode());
+  if (!persistent_handle_table_.search(lookup)) {
+    persistent_handle_data_ = new PersistentHandleData();
+    persistent_handle_table_.insert(lookup, persistent_handle_data_);
+  } else {
+    persistent_handle_data_ = (PersistentHandleData *)(
+        persistent_handle_table_.get(lookup));
+  }
+  persistent_handle_lookup_ = lookup;
+}
+
+
+void Isolate::ExitPersistentHandleMode() {
+  CHECK(InPersistentHandleMode());
+  persistent_handle_data_ = NULL;
+  persistent_handle_lookup_ = NULL;
+}
+
+
+bool Isolate::InPersistentHandleMode() {
+  return (persistent_handle_data_ != NULL);
+}
+
+
+Object **Isolate::CreatePersistentHandle(Object *value) {
+  CHECK(InPersistentHandleMode());
+  return persistent_handle_data_->CreateHandle(value);
+}
+
+
+void Isolate::DestroyPersistentHandles(void *lookup) {
+  CHECK(persistent_handle_lookup_ != lookup);
+  PersistentHandleData *data = (PersistentHandleData *)(
+      persistent_handle_table_.get(lookup));
+  if (data != NULL) {
+    delete data;
+    persistent_handle_table_.remove(lookup);
+  }
+}
+
+
+Isolate::V8GCHashTable::V8GCHashTable(Isolate *isolate,
+                                      void (*value_destructor)(Isolate *,
+                                                               void *))
+    : isolate_(isolate) {
+  isolate_->EnterPersistentHandleMode(this);
+  weak_map_ = isolate_->factory()->NewJSWeakMap();
+  isolate_->ExitPersistentHandleMode();
+
+  {
+    // Initialize() is going to make a Handle of the backing
+    // ObjectHashTable - don't make it persistent!
+    HandleScope scope(isolate_);
+    JSWeakCollection::Initialize(weak_map_, isolate_, true);
+  }
+
+  if (value_destructor != NULL) {
+    weak_map_->set_value_destructor(
+        reinterpret_cast<Object *>(value_destructor));
+  }
+}
+
+
+Isolate::V8GCHashTable::~V8GCHashTable() {
+  // TODO: Invoke value destructor if set.
+  HandleScope scope(isolate_);
+  weak_map_ = Handle<JSWeakMap>::null();
+  isolate_->DestroyPersistentHandles(this);
+}
+
+
+bool Isolate::V8GCHashTable::empty() {
+  return (size() == 0);
+}
+
+
+int Isolate::V8GCHashTable::size() {
+  HandleScope scope(isolate_);
+  Handle<ObjectPointerHashTable> table(get_table());
+  return table->NumberOfElements();
+}
+
+
+void Isolate::V8GCHashTable::insert(void *key, void *value) {
+  HandleScope scope(isolate_);
+  Handle<Object> obj_key(reinterpret_cast<Object *>(key), isolate_);
+  Handle<Object> obj_value(reinterpret_cast<Object *>(value), isolate_);
+  obj_key = get_key_handle(*obj_key);
+  obj_value = get_value_handle(*obj_value);
+  CHECK(obj_key->IsHeapObject());
+  int32_t hash = Object::GetOrCreateHash(isolate_, obj_key)->value();
+  JSWeakCollection::Set(weak_map_, obj_key, obj_value, hash);
+}
+
+
+void Isolate::V8GCHashTable::remove(void *key) {
+  HandleScope scope(isolate_);
+  Handle<Object> obj_key = get_key_handle(key);
+  int32_t hash = Object::GetOrCreateHash(isolate_, obj_key)->value();
+  JSWeakCollection::Delete(weak_map_, obj_key, hash);
+}
+
+
+bool Isolate::V8GCHashTable::search(void *key) {
+  HandleScope scope(isolate_);
+  Handle<ObjectPointerHashTable> table(get_table());
+  Handle<Object> obj_key = get_key_handle(key);
+  return (table->Lookup(obj_key) != isolate_->heap()->the_hole_value());
+}
+
+
+void *Isolate::V8GCHashTable::get(void *key) {
+  HandleScope scope(isolate_);
+  Handle<ObjectPointerHashTable> table(get_table());
+  Handle<Object> obj_key = get_key_handle(key);
+  Object *value = table->Lookup(obj_key);
+  if (value == isolate_->heap()->the_hole_value())
+    return NULL;
+  return value;
+}
+
+
+ObjectPointerHashTable *Isolate::V8GCHashTable::get_table() {
+  return ObjectPointerHashTable::cast(weak_map_->table());
+}
+
+
+void Isolate::V8GCHashTable::iterate(commons::IterateCallback callback,
+                                     void *data) {
+
+}
+
+
+Handle<Object> Isolate::V8GCHashTable::get_key_handle(void *key) {
+  Handle<Object> key_handle(reinterpret_cast<Object *>(key), isolate_);
+  if (!key_handle->IsHeapObject()) {
+    Object **location = reinterpret_cast<Object **>(non_heap_keys_.get(key));
+    if (location == NULL) {
+      isolate_->EnterPersistentHandleMode(this);
+      // Value does not really matter, we just need _some_ unique
+      // heap object to map the key to.
+      Handle<HeapNumber> heap_key_handle = isolate_->factory()->NewHeapNumber(
+          static_cast<double>(reinterpret_cast<intptr_t>(key)));
+      isolate_->ExitPersistentHandleMode();
+
+      location = reinterpret_cast<Object **>(heap_key_handle.location());
+      non_heap_keys_.insert(key, location);
+    }
+    key_handle = Handle<Object>(location);
+  }
+  return key_handle;
+}
+
+
+Handle<Object> Isolate::V8GCHashTable::get_value_handle(void *value) {
+  return Handle<Object>(reinterpret_cast<Object *>(value), isolate_);
+}
+
+
+void Isolate::EnqueueValueForDestroy(
+    void *value, void (*value_destructor)(Isolate *, void *)) {
+  values_to_destroy_.insert(value, reinterpret_cast<void *>(value_destructor));
+}
+
+
+void Isolate::IterateDestroyQueuedValues(void *key, void *value, void *data) {
+  Isolate *isolate = reinterpret_cast<Isolate *>(data);
+  void (*value_destructor)(Isolate *, void *) =
+      reinterpret_cast<void (*)(Isolate *, void *)>(value);
+  value_destructor(isolate, key);
+}
+
+
+void Isolate::DestroyQueuedValues() {
+  values_to_destroy_.iterate(IterateDestroyQueuedValues, this);
+  values_to_destroy_.clear();
+}
+
+
+void Isolate::IterateScopeDFGDestructor(void *key, void *value, void *data) {
+  delete (ScopeDFG *)value;
+}
+
+
+void Isolate::IterateScopeAndNodeDestructor(void *key,
+                                            void *value,
+                                            void *data) {
+  commons::HashTable *inner_table = (commons::HashTable *)value;
+  inner_table->iterate(IterateScopeAndNodeInnerDestructor, NULL);
+  delete inner_table;
+}
+
+
+void Isolate::IterateScopeAndNodeInnerDestructor(void *key,
+                                                 void *value,
+                                                 void *data) {
+  delete (ScopeAndNode *)value;
+}
+
+
+void Isolate::DisposeCompilationInfo(CompilationInfo *info) {
+  CHECK(info != NULL);
+
+  Zone *zone = info->zone();
+  delete zone;
+  delete info->parse_info();
+  delete info;
+  DestroyPersistentHandles(zone);
+
+  commons::HashTable *table;
+
+  table = (commons::HashTable *)scope_dfg_cache_.get(info);
+  if (table != NULL) {
+    table->iterate(IterateScopeDFGDestructor, NULL);
+    delete table;
+    scope_dfg_cache_.remove(info);
+  }
+
+  table = (commons::HashTable *)located_scope_and_node_cache_.get(info);
+  if (table != NULL) {
+    table->iterate(IterateScopeAndNodeDestructor, NULL);
+    delete table;
+    located_scope_and_node_cache_.remove(info);
+  }
+}
+
+
+static v8::Extension *dummy_extension = new v8::Extension("DummyExtension");
+
+
+static bool IsEvalToplevel(Handle<SharedFunctionInfo> shared) {
+  return shared->is_toplevel() && shared->script()->IsScript() &&
+         Script::cast(shared->script())->compilation_type() ==
+             Script::COMPILATION_TYPE_EVAL;
+}
+
+
+CompilationInfo *Isolate::GetCompilationInfo(Handle<JSFunction> function) {
+  CompilationInfo *info = NULL;
+  Handle<SharedFunctionInfo> shared(function->shared());
+
+  info = (CompilationInfo *)permanent_ast_cache_->get(*shared);
+  if (info != NULL)
+    return info;
+
+  lookup_count_ += 1;
+  if (lookup_count_ == 10240) {
+    //printf("Hit rate = %.2f\n", (double)hit_count_ / lookup_count_);
+    hit_count_ = lookup_count_ = 0;
+  }
+
+  info = (CompilationInfo *)ast_cache_->get(*shared);
+  if (info != NULL) {
+    hit_count_ += 1;
+    return info;
+  }
+
+  /*
+   * Cache miss, parse for AST and insert into cache.
+   */
+
+#define AST_CACHE_LIMIT  (1 << 20)
+
+  Zone *zone = new Zone(function->GetIsolate()->allocator());
+  EnterPersistentHandleMode(zone);
+
+  ParseInfo *parse_info = new ParseInfo(zone, Handle<JSFunction>(function));
+  if (IsEvalToplevel(shared)) {
+    parse_info->set_eval();
+    if (function->context()->IsNativeContext())
+      parse_info->set_global();
+    parse_info->set_toplevel();
+    parse_info->set_allow_lazy_parsing(false);
+    parse_info->set_lazy(false);
+  }
+  if (shared->IsBuiltin())
+    parse_info->set_extension(dummy_extension);
+
+  CHECK(Compiler::ParseAndAnalyze(parse_info));
+  info = new CompilationInfo(parse_info, Handle<JSFunction>(function));
+
+  ExitPersistentHandleMode();
+
+  if (ast_cache_->size() == AST_CACHE_LIMIT) {
+    // Eviction. For now we just get the first valid entry in
+    // the |ast_cache_| hash table.
+    Handle<ObjectPointerHashTable> table(ast_cache_->get_table());
+    Handle<SharedFunctionInfo> victim;
+    for (int i = 0; i < table->Capacity(); i++) {
+      Object *obj = table->KeyAt(i);
+      if (table->IsKey(obj)) {
+        victim = Handle<SharedFunctionInfo>(SharedFunctionInfo::cast(obj));
+        break;
+      }
+    }
+    CHECK(!victim.is_null());
+    CompilationInfo *victim_info = (CompilationInfo *)ast_cache_->get(*victim);
+    CHECK(victim_info != NULL);
+    // Do enqueue before remove.
+    EnqueueValueForDestroy(victim_info, AstCacheValueDestructor);
+    ast_cache_->remove(*victim);
+  }
+
+  CHECK(ast_cache_->size() < AST_CACHE_LIMIT);
+  ast_cache_->insert(*shared, info);
+
+#undef AST_CACHE_LIMIT
+
+  return info;
+}
+
+
+ScopeDFG *Isolate::GetScopeDFG(CompilationInfo *info, long position) {
+  commons::HashTable *table = (commons::HashTable *)scope_dfg_cache_.get(info);
+  if (table == NULL) {
+    table = new commons::HashTable();
+    scope_dfg_cache_.insert(info, table);
+  }
+
+  ScopeDFG *dfg = (ScopeDFG *)table->get((void *)position);
+  if (dfg == NULL) {
+    ScopeLocator locator(this, info->scope(), position);
+    locator.Locate(info->literal()->body());
+    if (locator.found()) {
+      ScopeDFGBuilder builder(this, locator.LocatedScope(),
+          locator.scope_dependencies(), locator.dependency_scopes());
+      dfg = builder.Build(locator.LocatedScopeStatements());
+      CHECK(dfg != NULL);
+      table->insert((void *)position, dfg);
+    }
+  }
+
+  return dfg;
+}
+
+
+void Isolate::AddLocatedScopeAndNode(CompilationInfo *info,
+                                     long type,
+                                     long position,
+                                     ScopeAndNode *cached) {
+  commons::HashTable *table =
+      (commons::HashTable *)located_scope_and_node_cache_.get(info);
+  if (table == NULL) {
+    table = new commons::HashTable();
+    located_scope_and_node_cache_.insert(info, table);
+  }
+
+  commons::HashTable *inner_table =
+      (commons::HashTable *)table->get((void *)type);
+  if (inner_table == NULL) {
+    inner_table = new commons::HashTable();
+    table->insert((void *)type, inner_table);
+  }
+
+  inner_table->insert((void *)position, cached);
+}
+
+
+ScopeAndNode *Isolate::LocatedScopeAndNode(CompilationInfo *info,
+                                           long type,
+                                           long position) {
+  commons::HashTable *table =
+      (commons::HashTable *)located_scope_and_node_cache_.get(info);
+  if (table == NULL)
+    return NULL;
+
+  commons::HashTable *inner_table =
+      (commons::HashTable *)table->get((void *)type);
+  if (inner_table == NULL)
+    return NULL;
+
+  return (ScopeAndNode *)inner_table->get((void *)position);
+}
+
+
+void Isolate::TaintTableValueDestructor(Isolate *isolate, void *value) {
+  if (value != NULL)
+    delete static_cast<std::vector<bool> *>(value);
+}
+
+
+void Isolate::SetTaintForV8Object(Handle<Object> obj,
+                                  std::vector<bool> tainted_bytes) {
+  obj = FilterInvalidV8Objects(this, obj);
+  if (obj.is_null() || obj->IsSmi())
+    return;
+
+  if (IsDoNotTaint(obj) || taint_table_->search(*obj))  // Do not overwrite.
+    return;
+
+  if (obj->IsString() && !tainted_bytes.empty()) {
+    CHECK(Handle<String>::cast(obj)->length() == tainted_bytes.size());
+    std::vector<bool> *ptb = new std::vector<bool>();
+    *ptb = tainted_bytes;
+    taint_table_->insert(*obj, ptb);
+  } else {
+    taint_table_->insert(*obj, NULL);
+  }
+}
+
+
+void Isolate::UntaintV8Object(Handle<Object> obj) {
+  void *ptr = taint_table_->get(*obj);
+  if (ptr != NULL)
+    EnqueueValueForDestroy(ptr, TaintTableValueDestructor);
+  taint_table_->remove(*obj);
+}
+
+
+/*
+ * Locks for SetV8ObjectAsTaintSource() and LogTaintSink().
+ */
+
+#define TESTLOCK_FILE  PROPAGATION_PATHS_OUT_DIR"testlock"
+#define LOCK_FILE      PROPAGATION_PATHS_OUT_DIR"lockfile"
+
+static void acquire_lock() {
+  // First test if we are in sandbox.
+  FILE *fp = fopen(TESTLOCK_FILE, "a");
+  if (fp == NULL)
+    return;  // Nothing to synchronize.
+  fclose(fp);
+
+  int fd = open(LOCK_FILE, O_CREAT | O_EXCL);
+  while (fd == -1)
+    fd = open(LOCK_FILE, O_CREAT | O_EXCL);
+  close(fd);
+}
+
+static void release_lock() {
+  unlink(LOCK_FILE);
+}
+
+#undef TESTLOCK_FILE
+#undef LOCK_FILE
+
+
+void Isolate::SetV8ObjectAsTaintSource(Handle<Object> obj,
+                                       Handle<JSFunction> function) {
+  obj = FilterInvalidV8Objects(this, obj);
+  if (!obj.is_null()) {
+    taint_source_objects_->insert(*obj, *function);
+
+    acquire_lock();
+
+    // Log this taint source.
+    FILE *fp = fopen(PROPAGATION_PATHS_OUT_DIR"taint_sources.log", "a");
+    if (fp != NULL) {
+      fprintf(fp, ">>> Taint source:\n");
+
+      obj->ShortPrint(fp);
+
+      SharedFunctionInfo *shared = function->shared();
+      fprintf(fp, "\n** In function %p `", *function);
+      std::unique_ptr<char[]> name = shared->DebugName()->ToCString();
+      fprintf(fp, "%s`, source code:\n", name.get());
+
+      if (shared->HasSourceCode()) {
+        Handle<String> source(String::cast(
+            Script::cast(shared->script())->source()));
+        std::string c_source(source->ToCString().get());
+        c_source = c_source.substr(shared->start_position(),
+            shared->end_position() - shared->start_position());
+        fprintf(fp, "%s\n", c_source.c_str());
+      }
+
+      fprintf(fp, ">>> END Taint source\n\n");
+      fclose(fp);
+    }
+
+    release_lock();
+  }
+}
+
+
+void Isolate::LogTaintSink(Handle<Object> obj,
+                           Handle<String> report,
+                           Handle<String> where) {
+  std::string c_where(where->ToCString().get());
+  std::cout << "Taint sink reached at `" << c_where << "`\n";
+
+  char buf[256];
+  snprintf(buf, 256, PROPAGATION_PATHS_OUT_DIR"taint_%s.log", c_where.c_str());
+
+  acquire_lock();
+
+  FILE *fp = fopen(buf, "a");
+  if (fp != NULL) {
+    fprintf(fp, ">>> TAINT SINK `%s` REACHED <<<\n", c_where.c_str());
+    PrintCurrentStackTrace(fp);
+    fprintf(fp, "\n///////////////////////// ");
+    fprintf(fp, "Details");
+    fprintf(fp, " /////////////////////////\n\n");
+
+    if (obj->IsString()) {
+      Handle<String> str = Handle<String>::cast(obj);
+      std::vector<bool> *tainted_bytes = GetStringTaintedBytes(str);
+      fprintf(fp, "** Tainted bytes: ");
+      if (tainted_bytes != NULL) {
+        for (size_t i = 0; i < tainted_bytes->size(); i++) {
+          if (tainted_bytes->at(i))
+            fprintf(fp, "1");
+          else
+            fprintf(fp, "0");
+        }
+      }
+      fprintf(fp, "\n\n");
+
+      fprintf(fp, "** Sink object: %s\n\n", str->ToCString().get());
+    } else {
+      fprintf(fp, "** Sink object: ");
+      obj->ShortPrint(fp);
+      fprintf(fp, "\n\n");
+    }
+
+    fprintf(fp, "%s\n\n", report->ToCString().get());
+    fprintf(fp, ">>> END TAINT SINK REPORT <<<\n");
+    fclose(fp);
+  }
+
+  release_lock();
+}
+
+
+bool Isolate::IsV8ObjectTainted(Handle<Object> obj) {
+  obj = FilterInvalidV8Objects(this, obj);
+  if (obj.is_null())
+    return false;
+  return taint_table_->search(*obj);
+}
+
+
+bool Isolate::IsStringTaintedAt(Handle<String> str, int idx) {
+  if (idx < 0 || idx >= str->length())
+      return false;
+  if (!IsV8ObjectTainted(Handle<Object>::cast(str)))
+    return false;
+
+  void *ptr = taint_table_->get(*str);
+  if (ptr == NULL)
+    return true;
+  std::vector<bool> *ptb = static_cast<std::vector<bool> *>(ptr);
+  CHECK(str->length() == ptb->size());
+  return ptb->at(idx);
+}
+
+
+std::vector<bool> *Isolate::GetStringTaintedBytes(Handle<String> str) {
+  return static_cast<std::vector<bool> *>(taint_table_->get(*str));
+}
+
+
+bool Isolate::IsV8ObjectPartiallyTainted(Handle<Object> obj) {
+  obj = FilterInvalidV8Objects(this, obj);
+  if (obj.is_null())
+    return false;
+  return (obj->IsString() &&
+      (GetStringTaintedBytes(Handle<String>::cast(obj)) != NULL));
+}
+
+
+void Isolate::SetDoNotTaint(Handle<Object> obj) {
+  obj = FilterInvalidV8Objects(this, obj);
+  if (!obj.is_null())
+    do_not_taint_->insert(*obj, NULL);
+}
+
+
+bool Isolate::IsDoNotTaint(Handle<Object> obj) {
+  return do_not_taint_->search(*obj);
+}
+
+
+commons::HashTable *Isolate::GetAstTaintTable(void *fp, bool alloc) {
+  commons::HashTable *table = (commons::HashTable *)(ast_taint_table_.get(fp));
+  if (table == NULL && alloc) {
+    table = new commons::HashTable();
+    ast_taint_table_.insert(fp, table);
+  }
+  return table;
+}
+
+
+void Isolate::DropAstTaintTable(void *fp) {
+  commons::HashTable *table = (commons::HashTable *)(ast_taint_table_.get(fp));
+  if (table != NULL) {
+    delete table;
+    ast_taint_table_.remove(fp);
+  }
+}
+
+
+void Isolate::SetTaintForAstNode(Handle<JSFunction> function,
+                                 void *fp,
+                                 int position,
+                                 int type) {
+  CHECK(type == AstNode::kVariableProxy ||
+        type == AstNode::kProperty ||
+        type == AstNode::kCall);
+  MakeASTPermanent(function);
+  commons::HashTable *table = GetAstTaintTable(fp, true);
+  table->insert(KEY_FROM_POSITION_AND_TYPE(position, type), NULL);
+}
+
+
+void Isolate::UntaintAstNode(void *fp, int position, int type) {
+  CHECK(type == AstNode::kVariableProxy ||
+        type == AstNode::kProperty ||
+        type == AstNode::kCall);
+  commons::HashTable *table = GetAstTaintTable(fp, false);
+  if (table == NULL)
+    return;
+  table->remove(KEY_FROM_POSITION_AND_TYPE(position, type));
+}
+
+
+bool Isolate::IsAstNodeTainted(void *fp, int position, int type) {
+  CHECK(type == AstNode::kVariableProxy ||
+        type == AstNode::kProperty ||
+        type == AstNode::kCall);
+  commons::HashTable *table = GetAstTaintTable(fp, false);
+  if (table == NULL)
+    return false;
+  return table->search(KEY_FROM_POSITION_AND_TYPE(position, type));
+}
+
+
+void Isolate::AddToObjectMap(void *fp,
+                             int position,
+                             int type,
+                             Handle<Object> object) {
+  CHECK(type == AstNode::kVariableProxy ||
+        type == AstNode::kProperty ||
+        type == AstNode::kCall);
+
+  object = FilterInvalidV8Objects(this, object);
+  if (object.is_null())
+    return;
+
+  // AST for |function| must be already pinned.
+  if (!ast_taint_table_.search(fp))
+    return;
+
+  V8GCHashTable *table = reinterpret_cast<V8GCHashTable *>(object_map_.get(fp));
+  if (table == NULL) {
+    table = new V8GCHashTable(this);
+    object_map_.insert(fp, table);
+  }
+  table->insert(KEY_FROM_POSITION_AND_TYPE(position, type), *object);
+}
+
+
+Handle<Object> Isolate::LookupObjectMap(void *fp, int position, int type) {
+  CHECK(type == AstNode::kVariableProxy ||
+        type == AstNode::kProperty ||
+        type == AstNode::kCall);
+
+  V8GCHashTable *table = reinterpret_cast<V8GCHashTable *>(object_map_.get(fp));
+  if (table == NULL)
+    return Handle<Object>::null();
+
+  Object *obj = reinterpret_cast<Object *>(
+      table->get(KEY_FROM_POSITION_AND_TYPE(position, type)));
+  return (obj == NULL) ? Handle<Object>::null() : Handle<Object>(obj, this);
+}
+
+
+void Isolate::DropObjectMap(void *fp) {
+  V8GCHashTable *table = reinterpret_cast<V8GCHashTable *>(object_map_.get(fp));
+  if (table != NULL) {
+    delete table;
+    object_map_.remove(fp);
+  }
+}
+
+
+void Isolate::AstCacheValueDestructor(Isolate *isolate, void *value) {
+  isolate->DisposeCompilationInfo((CompilationInfo *)value);
+}
+
+
+void Isolate::MakeASTPermanent(Handle<JSFunction> function) {
+  if (permanent_ast_cache_->search(function->shared()))
+    return;
+
+  EnterPersistentHandleMode(this);
+  Handle<SharedFunctionInfo> shared(function->shared());  // Pin this first.
+  ExitPersistentHandleMode();
+
+  // XXX: I guess the reason for this CHECK was that
+  // the AST cache used to be LRU-replaced, so we can
+  // expect that the AST is never evicted.
+  //CHECK(ast_cache_->search(function->shared()));
+
+  CompilationInfo *info = GetCompilationInfo(function);
+  // These statements might trigger GC.
+  permanent_ast_cache_->insert(*shared, info);
+  ast_cache_->remove(function->shared());
+}
+
+
+void Isolate::MarkAsExtensionContext(Handle<Context> context,
+                                     bool is_background) {
+  CHECK(context->IsNativeContext());
+  if (is_background)
+    extension_contexts_->insert(*context, (void *)(0x2UL));
+  else
+    extension_contexts_->insert(*context, NULL);
+}
+
+
+bool Isolate::InExtensionContext(Handle<JSFunction> function) {
+  return extension_contexts_->search(function->context()->native_context());
+}
+
+
+bool Isolate::IsBackgroundPageContext(Handle<JSFunction> function) {
+  if (!InExtensionContext(function))
+    return false;
+
+  return (extension_contexts_->get(
+      function->context()->native_context())) != NULL;
+}
+
+
+void Isolate::TaintJSFunction(Handle<JSFunction> function,
+                              Handle<String> report) {
+  tainted_js_functions_->insert(*function, *report);
+}
+
+
+bool Isolate::IsJSFunctionTainted(Handle<JSFunction> function) {
+  return tainted_js_functions_->search(*function);
+}
+
+
+Handle<String> Isolate::GetPropagationPathForJSFunction(
+    Handle<JSFunction> function) {
+  String *report = (String *)tainted_js_functions_->get(*function);
+  if (report != NULL)
+    return Handle<String>(report);
+  return Handle<String>::null();
+}
+
+
+void Isolate::AddDoNotPropagate(Handle<JSFunction> caller,
+                                Handle<JSFunction> callee) {
+  do_not_propagate_->insert(*caller, *callee);
+}
+
+
+bool Isolate::IsDoNotPropagate(Handle<JSFunction> caller,
+                               Handle<JSFunction> callee) {
+  return (do_not_propagate_->get(*caller) == *callee);
+}
+
+
+void Isolate::ClearDoNotPropagate(Handle<JSFunction> caller) {
+  do_not_propagate_->remove(*caller);
+}
+
+
+void Isolate::AddDoNotPropagateFunction(Handle<JSFunction> function) {
+  do_not_propagate_functions_->insert(function->shared(), NULL);
+}
+
+
+bool Isolate::IsDoNotPropagateFunction(Handle<JSFunction> function) {
+  return do_not_propagate_functions_->search(function->shared());
+}
+
+
+void Isolate::MarkAsTaintSource(Handle<JSFunction> function) {
+  if (!function.is_null()) {
+    Handle<String> stack_trace = GetCurrentStackTrace();
+    taint_sources_->insert(*function, *stack_trace);
+  }
+}
+
+
+bool Isolate::IsTaintSource(Handle<JSFunction> function) {
+  return taint_sources_->search(*function);
+}
+
+
+#ifdef DISABLE_PROPAGATION_REPORT
+
+void Isolate::AddPropagatedFrom(Handle<Object> obj,
+                                Handle<JSFunction> function,
+                                AstNode *node,
+                                Handle<Object> from_obj) {
+}
+
+
+void Isolate::AddPropagatedFrom(Handle<Object> obj,
+                                Handle<JSFunction> function,
+                                Handle<String> report) {
+}
+
+
+Handle<String> Isolate::GetPropagationPaths(Handle<Object> obj) {
+  return factory()->empty_string();
+}
+
+
+void Isolate::PrintPropagationPaths(Handle<Object> obj, FILE *out) {}
+
+#else  // DISABLE_PROPAGATION_REPORT
+
+void * const Isolate::ipc_pseudo_node_ = (void * const)0xdeadbeefUL;
+
+
+void Isolate::IteratePropagatedFromDestructor(void *key,
+                                              void *value,
+                                              void *data) {
+  delete reinterpret_cast<struct PropagatedFrom *>(value);
+}
+
+
+void Isolate::PropagatedFromValueDestructor(Isolate *isolate, void *value) {
+  commons::HashTable *table = reinterpret_cast<commons::HashTable *>(value);
+  // Better to unlink the handles from GC first.
+  isolate->DestroyPersistentHandles(table);
+  table->iterate(IteratePropagatedFromDestructor, NULL);
+}
+
+
+void Isolate::AddPropagatedFromCommon(Handle<Object> obj,
+                                      Handle<JSFunction> function,
+                                      void *from_node,
+                                      PropagatedFrom::FromNodeType from_type,
+                                      Handle<Object> from_obj) {
+  obj = FilterInvalidV8Objects(this, obj);
+  from_obj = FilterInvalidV8Objects(this, from_obj);
+  if (obj.is_null() || obj->IsSmi() || from_obj.is_null() || from_obj->IsSmi())
+    return;
+
+  commons::HashTable *table = (commons::HashTable *)propagated_from_->get(*obj);
+  if (table == NULL) {
+    table = new commons::HashTable();
+    propagated_from_->insert(*obj, table);
+  }
+
+  if (table->search(from_node))
+    return;  // Do not overwrite.
+
+  struct PropagatedFrom *from_info = new struct PropagatedFrom;
+  from_info->from_type = from_type;
+
+  EnterPersistentHandleMode(table);
+  from_info->function = Handle<JSFunction>(*function, this);
+  from_info->from_obj = Handle<Object>(*from_obj, this);
+  ExitPersistentHandleMode();
+
+  table->insert(from_node, from_info);
+}
+
+
+void Isolate::AddPropagatedFrom(Handle<Object> obj,
+                                Handle<JSFunction> function,
+                                AstNode *node,
+                                Handle<Object> from_obj) {
+  AddPropagatedFromCommon(obj, function,
+      node, PropagatedFrom::ASTNODE, from_obj);
+}
+
+
+void Isolate::AddPropagatedFrom(Handle<Object> obj,
+                                Handle<JSFunction> function,
+                                Handle<String> report) {
+  AddPropagatedFromCommon(obj, function,
+      ipc_pseudo_node_, PropagatedFrom::PSEUDO, Handle<Object>::cast(report));
+}
+
+
+void Isolate::IteratePrintTaintSourceObjects(void *key,
+                                             void *value,
+                                             void *data) {
+  Isolate *isolate = (Isolate *)data;
+  Object *obj = (Object *)key;
+  JSFunction *function = (JSFunction *)value;
+  SharedFunctionInfo *shared = function->shared();
+
+  std::stringstream &ss = isolate->propagation_paths_ss_;
+
+  obj->Print(ss);
+  ss << ", in function " << function << " `";
+  std::unique_ptr<char[]> name = shared->DebugName()->ToCString();
+  ss << name.get() << "`: " << shared->start_position() << "\n";
+}
+
+
+void Isolate::IteratePrintPropagationPathFunctions(void *key,
+                                                   void *value,
+                                                   void *data) {
+  Isolate *isolate = (Isolate *)data;
+  JSFunction *function = (JSFunction *)key;
+  SharedFunctionInfo *shared = function->shared();
+
+  std::stringstream &ss = isolate->propagation_paths_ss_;
+
+  ss << function << " `";
+  std::unique_ptr<char[]> name = shared->DebugName()->ToCString();
+  ss << name.get() << "`: " << shared->start_position() << "\n";
+
+  if (shared->HasSourceCode()) {
+    Handle<String> source(String::cast(
+        Script::cast(shared->script())->source()));
+    std::string c_source(source->ToCString().get());
+    ss << c_source.substr(shared->start_position(),
+        shared->end_position() - shared->start_position());
+    ss << "\n";
+  }
+}
+
+
+void Isolate::IteratePrintTaintSourceFunctions(void *key,
+                                               void *value,
+                                               void *data) {
+  Isolate *isolate = (Isolate *)data;
+  JSFunction *function = (JSFunction *)key;
+  SharedFunctionInfo *shared = function->shared();
+  String *stack_trace = (String *)value;
+
+  std::stringstream &ss = isolate->propagation_paths_ss_;
+  bool on_propagation_path =
+      isolate->propagation_path_functions_.search(function);
+
+  if (on_propagation_path)
+    ss << "* ";
+
+  ss << function << " `";
+  std::unique_ptr<char[]> name = shared->DebugName()->ToCString();
+  ss << name.get() << "`: " << shared->start_position() << "\n";
+
+  ss << stack_trace->ToCString().get() << "\n";
+
+  if (shared->HasSourceCode()) {
+    Handle<String> source(String::cast(
+        Script::cast(shared->script())->source()));
+    std::string c_source(source->ToCString().get());
+    ss << c_source.substr(shared->start_position(),
+        shared->end_position() - shared->start_position());
+    ss << "\n";
+  }
+}
+
+
+void Isolate::IteratePrintPropagationPath(void *key, void *value, void *data) {
+  Isolate *isolate = (Isolate *)data;
+  struct PropagatedFrom *from_info =
+      reinterpret_cast<struct PropagatedFrom *>(value);
+
+  if (key != isolate->ipc_pseudo_node_) {
+    JSFunction *function = *(from_info->function);
+    Object *obj = *(from_info->from_obj);
+    isolate->propagation_path_functions_.insert(function, NULL);
+    if (isolate->propagated_from_->search(obj))
+      isolate->DoPrintPropagationPath(Handle<Object>(obj, isolate));
+  }
+}
+
+
+void Isolate::IteratePrintPropagationPrev(void *key, void *value, void *data) {
+  Isolate *isolate = (Isolate *)data;
+  struct PropagatedFrom *from_info =
+      reinterpret_cast<struct PropagatedFrom *>(value);
+
+  std::stringstream &ss = isolate->propagation_paths_ss_;
+
+  if (key == isolate->ipc_pseudo_node_) {
+    std::unique_ptr<char []> flat_report =
+        String::cast(*(from_info->from_obj))->ToCString();
+    ss << ">> IPC Object:\n" << flat_report.get() << "\n>> END IPC Object\n";
+  } else if (isolate->propagates_to_ != *(from_info->from_obj)) {
+    JSFunction *function = *(from_info->function);
+    Object *obj = *(from_info->from_obj);
+
+    ss << "  ";
+    obj->Print(ss);
+
+    ss << ", in function " << function << " `";
+    std::unique_ptr<char[]> name = function->shared()->DebugName()->ToCString();
+    ss << name.get() << "`: " << function->shared()->start_position() << ", ";
+
+    switch(from_info->from_type) {
+    case PropagatedFrom::ASTNODE:
+      ss << ((AstNode *)key)->position();
+      break;
+    case PropagatedFrom::PSEUDO:
+      UNREACHABLE();
+      break;
+    }
+
+    ss << "\n";
+  }
+}
+
+
+void Isolate::DoPrintPropagationPath(Handle<Object> obj) {
+  if (propagation_path_objects_.search(*obj))
+    return;
+
+  propagation_path_objects_.insert(*obj, NULL);
+
+  std::stringstream &ss = propagation_paths_ss_;
+
+  obj->Print(ss);
+  ss << ":\n";
+
+  commons::HashTable *table = (commons::HashTable *)propagated_from_->get(*obj);
+  if (table != NULL) {
+    Object *saved_propagates_to = propagates_to_;
+    propagates_to_ = *obj;
+    table->iterate(IteratePrintPropagationPrev, this);
+    propagates_to_ = saved_propagates_to;
+    ss << "\n";
+    table->iterate(IteratePrintPropagationPath, this);
+  }
+}
+
+
+void Isolate::CollectPropagationPaths(Handle<Object> obj) {
+  propagation_paths_ss_.str("");
+  if (!propagated_from_->search(*obj))
+    return;
+
+  propagation_path_objects_.clear();
+  propagation_path_functions_.clear();
+
+  {
+    DisallowHeapAllocation no_gc;  // Don't trigger GC here!
+
+    JavaScriptFrameIterator it(this);
+    propagation_path_functions_.insert(it.frame()->function(), NULL);
+
+    propagation_paths_ss_ << "** Propagation paths: \n\n";
+    DoPrintPropagationPath(obj);
+
+    propagation_paths_ss_ << "\n** Taint source objects:\n\n";
+    taint_source_objects_->iterate(IteratePrintTaintSourceObjects, this);
+
+    propagation_paths_ss_ << "\n** Propagation path functions: \n\n";
+    propagation_path_functions_.iterate(
+        IteratePrintPropagationPathFunctions, this);
+
+    propagation_paths_ss_ << "\n** Taint source functions: \n\n";
+    taint_sources_->iterate(IteratePrintTaintSourceFunctions, this);
+
+    propagation_paths_ss_ << "\n";
+  }
+}
+
+
+void Isolate::PrintPropagationPaths(Handle<Object> obj, FILE *out) {
+  CollectPropagationPaths(obj);
+  fprintf(out, "%s", propagation_paths_ss_.str().c_str());
+}
+
+
+Handle<String> Isolate::GetPropagationPaths(Handle<Object> obj) {
+  CollectPropagationPaths(obj);
+  const std::string &paths = propagation_paths_ss_.str();
+  if (paths.empty())
+    return factory()->empty_string();
+
+  FILE *fp;
+  char buf[256];
+
+  snprintf(buf, 256, PROPAGATION_PATHS_OUT_DIR"%08x.log", 0);
+  if ((fp = fopen(buf, "w")) == NULL)  // We are in sandbox.
+    return factory()->empty_string();
+
+  for (int i = 1; i < INT_MAX; i++) {
+    snprintf(buf, 256, PROPAGATION_PATHS_OUT_DIR"%08x.log", i);
+    if ((fp = fopen(buf, "r")) != NULL) {
+      fclose(fp);  // File exists.
+      continue;
+    }
+    fp = fopen(buf, "w");
+    break;
+  }
+
+  if (fp == NULL)
+    return factory()->empty_string();
+
+  fprintf(fp, "%s", paths.c_str());
+  fclose(fp);
+
+  return factory()->NewStringFromUtf8(
+      Vector<const char>(buf, strlen(buf))).ToHandleChecked();
+}
+
+#endif  // DISABLE_PROPAGATION_REPORT
+
+
+Handle<String> Isolate::GetCurrentStackTrace() {
+  std::stringstream ss;
+
+  // Borrowed from Isolate::PrintCurrentStackTrace().
+  StackTraceFrameIterator it(this);
+  while (!it.done()) {
+    HandleScope scope(this);
+    // Find code position if recorded in relocation info.
+    StandardFrame* frame = it.frame();
+    AbstractCode* abstract_code;
+    int code_offset;
+    if (frame->is_interpreted()) {
+      InterpretedFrame* iframe = reinterpret_cast<InterpretedFrame*>(frame);
+      abstract_code = AbstractCode::cast(iframe->GetBytecodeArray());
+      code_offset = iframe->GetBytecodeOffset();
+    } else {
+      DCHECK(frame->is_java_script() || frame->is_wasm());
+      Code* code = frame->LookupCode();
+      abstract_code = AbstractCode::cast(code);
+      code_offset = static_cast<int>(frame->pc() - code->instruction_start());
+    }
+    int pos = abstract_code->SourcePosition(code_offset);
+    JavaScriptFrame* js_frame = JavaScriptFrame::cast(frame);
+    Handle<Object> pos_obj(Smi::FromInt(pos), this);
+    // Fetch function and receiver.
+    Handle<JSFunction> fun(js_frame->function(), this);
+    Handle<Object> recv(js_frame->receiver(), this);
+    // Advance to the next JavaScript frame and determine if the
+    // current frame is the top-level frame.
+    it.Advance();
+    Handle<Object> is_top_level = factory()->ToBoolean(it.done());
+    // Generate and print stack trace line.
+    Handle<String> line =
+        Execution::GetStackTraceLine(recv, fun, pos_obj, is_top_level);
+    if (line->length() > 0)
+      ss << "  " << line->ToCString().get() << "\n";
+  }
+
+  return factory()->NewStringFromUtf8(
+      Vector<const char>(ss.str().c_str(), ss.str().size())).ToHandleChecked();
+}
+
+
+Handle<String> Isolate::prepend_marker() {
+  if (prepend_marker_.is_null()) {
+    EnterPersistentHandleMode(this);
+    Handle<String> str = factory()->NewStringFromOneByte(
+        Vector<const uint8_t>((uint8_t*)PREPEND_MARKER,
+                              strlen(PREPEND_MARKER))).ToHandleChecked();
+    ExitPersistentHandleMode();
+    prepend_marker_ = str;
+  }
+  return prepend_marker_;
+}
+
+
+Handle<String> Isolate::append_marker() {
+  if (append_marker_.is_null()) {
+    EnterPersistentHandleMode(this);
+    Handle<String> str = factory()->NewStringFromOneByte(
+        Vector<const uint8_t>((uint8_t*)APPEND_MARKER,
+                              strlen(APPEND_MARKER))).ToHandleChecked();
+    ExitPersistentHandleMode();
+    append_marker_ = str;
+  }
+  return append_marker_;
+}
+
+
+bool Isolate::InHoneyPage() {
+  HandleScope scope(this);
+
+  JavaScriptFrameIterator it(this);
+  Handle<SharedFunctionInfo> shared(it.frame()->function()->shared());
+  if (shared->HasSourceCode()) {
+    Handle<String> source(String::cast(
+        Script::cast(shared->script())->source()));
+
+    int prepend_idx = String::IndexOf(this, source, prepend_marker(), 0);
+    if (prepend_idx != -1 && shared->end_position() < prepend_idx)
+      return true;
+
+    int append_idx = String::IndexOf(this, source, append_marker(), 0);
+    if (append_idx != -1 && shared->start_position() > append_idx)
+      return true;
+  }
+
+  return false;
+}
+
+
 void Isolate::InitializeThreadLocal() {
   thread_local_top_.isolate_ = this;
   thread_local_top_.Initialize();
@@ -2507,6 +3746,23 @@ bool Isolate::Init(Deserializer* des) {
 
   if (!FLAG_inline_new) heap_.DisableInlineAllocation();
 
+  permanent_ast_cache_ = new V8GCHashTable(this, AstCacheValueDestructor);
+  ast_cache_ = new V8GCHashTable(this, AstCacheValueDestructor);
+  taint_table_ = new V8GCHashTable(this, TaintTableValueDestructor);
+  do_not_taint_ = new V8GCHashTable(this);
+
+  extension_contexts_ = new V8GCHashTable(this);
+  tainted_js_functions_ = new V8GCHashTable(this);
+  taint_source_objects_ = new V8GCHashTable(this);
+  taint_sources_ = new V8GCHashTable(this);
+
+#ifndef DISABLE_PROPAGATION_REPORT
+  propagated_from_ = new V8GCHashTable(this, PropagatedFromValueDestructor);
+#endif
+
+  do_not_propagate_ = new V8GCHashTable(this);
+  do_not_propagate_functions_ = new V8GCHashTable(this);
+
   return true;
 }
 
diff --git a/src/isolate.h b/src/isolate.h
index eb1841d4d8..1e8b5651a8 100644
--- a/src/isolate.h
+++ b/src/isolate.h
@@ -26,6 +26,9 @@
 #include "src/tracing/trace-event.h"
 #include "src/zone.h"
 
+#include <sstream>
+#include "src/commons.h"
+
 namespace v8 {
 
 namespace base {
@@ -94,6 +97,10 @@ namespace interpreter {
 class Interpreter;
 }
 
+static inline bool HandleStringEquals(Handle<String> str, const char *other) {
+  return str->IsUtf8EqualTo(Vector<const char>(other, strlen(other)));
+}
+
 // Static indirection table for handles to constants.  If a frame
 // element represents a constant, the data contains an index into
 // this table of handles to the actual constants.
@@ -444,6 +451,12 @@ typedef List<HeapObject*> DebugObjectCache;
   type* name##_address() { return &thread_local_top_.name##_; }
 
 
+class CompilationInfo;
+class AstNode;
+class Property;
+class ScopeDFG;
+struct ScopeAndNode;
+
 class Isolate {
   // These forward declarations are required to make the friend declarations in
   // PerIsolateThreadData work on some older versions of gcc.
@@ -1165,6 +1178,155 @@ class Isolate {
 
   bool IsIsolateInBackground() { return is_isolate_in_background_; }
 
+  //
+  // Taint analysis stuff.
+  //
+
+  void IterateTaintAnalysisStuff(ObjectVisitor *v);
+  void PostGCHook();
+
+  // Another GCHashTable implementation.
+  class V8GCHashTable {
+   public:
+    V8GCHashTable(Isolate *isolate,
+                  void (*value_destructor)(Isolate *, void *) = NULL);
+
+    ~V8GCHashTable();
+
+    bool empty();
+    int size();
+
+    void insert(void *key, void *value);
+    void remove(void *key);
+    bool search(void *key);
+    void *get(void *key);
+
+    ObjectPointerHashTable *get_table();
+
+    void iterate(commons::IterateCallback callback, void *data);
+
+   private:
+    Isolate *isolate_;
+    Handle<JSWeakMap> weak_map_;
+
+    Handle<Object> get_key_handle(void *key);
+    Handle<Object> get_value_handle(void *value);
+    commons::HashTable non_heap_keys_;
+  };
+
+  // Queue up V8GCHashTable values for which the corresponding destructors
+  // should be applied at GC epilogue.
+  void EnqueueValueForDestroy(void *value,
+                              void (*value_destructor)(Isolate *, void *));
+  // Called from PostGCHook().
+  void DestroyQueuedValues();
+
+  // Persistent Handle.
+
+  void EnterPersistentHandleMode(void *lookup);
+  void ExitPersistentHandleMode();
+  bool InPersistentHandleMode();
+  Object **CreatePersistentHandle(Object *value);
+  void DestroyPersistentHandles(void *lookup);
+
+  // AST generation and searching.
+
+  CompilationInfo *GetCompilationInfo(Handle<JSFunction> function);
+  ScopeDFG *GetScopeDFG(CompilationInfo *info, long position);
+  void AddLocatedScopeAndNode(CompilationInfo *info,
+                              long type, long position, ScopeAndNode *cached);
+  ScopeAndNode *LocatedScopeAndNode(CompilationInfo *info,
+                                    long type, long position);
+
+  // OBJ taint table operations.
+
+  void SetTaintForV8Object(Handle<Object> obj,
+                           std::vector<bool> tainted_bytes=std::vector<bool>());
+  void UntaintV8Object(Handle<Object> obj);
+  bool IsV8ObjectTainted(Handle<Object> obj);
+
+  bool IsStringTaintedAt(Handle<String> str, int idx);
+  std::vector<bool> *GetStringTaintedBytes(Handle<String> str);
+  bool IsV8ObjectPartiallyTainted(Handle<Object> obj);
+
+  bool HasTaintedV8Objects() { return !taint_table_->empty(); }
+
+  // V8 objects that should not be tainted.
+  void SetDoNotTaint(Handle<Object> obj);
+  bool IsDoNotTaint(Handle<Object> obj);
+
+  // Per-invocation AST taint table.
+
+  commons::HashTable *GetAstTaintTable(void *fp, bool alloc);
+  void DropAstTaintTable(void *fp);
+
+  void SetTaintForAstNode(Handle<JSFunction> function,
+                          void *fp,
+                          int position,
+                          int type);
+  void UntaintAstNode(void *fp, int position, int type);
+  bool IsAstNodeTainted(void *fp, int position, int type);
+
+  // Per-invocation mapping from AST node to V8 object.
+
+  void AddToObjectMap(void *fp, int position, int type, Handle<Object> object);
+  Handle<Object> LookupObjectMap(void *fp, int position, int type);
+  void DropObjectMap(void *fp);
+
+  // Extension JavaScript contexts.
+
+  void MarkAsExtensionContext(Handle<Context> context, bool is_background);
+  bool InExtensionContext(Handle<JSFunction> function);
+  bool IsBackgroundPageContext(Handle<JSFunction> function);
+
+  // For propagation reports.
+
+  void SetV8ObjectAsTaintSource(Handle<Object> obj,
+                                Handle<JSFunction> function);
+
+  void LogTaintSink(Handle<Object> obj,
+                    Handle<String> report,
+                    Handle<String> where);
+
+  void TaintJSFunction(Handle<JSFunction> function, Handle<String> report);
+  bool IsJSFunctionTainted(Handle<JSFunction> function);
+  Handle<String> GetPropagationPathForJSFunction(Handle<JSFunction> function);
+
+  void MarkAsTaintSource(Handle<JSFunction> function);
+  bool IsTaintSource(Handle<JSFunction> function);
+
+  void AddPropagatedFrom(Handle<Object> obj,
+                         Handle<JSFunction> function,
+                         AstNode *node,
+                         Handle<Object> from_obj);
+
+  // Propagation paths for IPC'ed objects. |node| will be ipc_pseudo_node_.
+  void AddPropagatedFrom(Handle<Object> obj,
+                         Handle<JSFunction> function,
+                         Handle<String> report);
+
+  Handle<String> GetPropagationPaths(Handle<Object> obj);
+  void PrintPropagationPaths(Handle<Object> obj, FILE *out = stdout);
+
+  Handle<String> GetCurrentStackTrace();
+
+  // Do-not-propagate for special case functions.
+
+  void AddDoNotPropagate(Handle<JSFunction> caller, Handle<JSFunction> callee);
+  bool IsDoNotPropagate(Handle<JSFunction> caller, Handle<JSFunction> callee);
+  void ClearDoNotPropagate(Handle<JSFunction> caller);
+
+  void AddDoNotPropagateFunction(Handle<JSFunction> function);
+  bool IsDoNotPropagateFunction(Handle<JSFunction> function);
+
+  Handle<String> prepend_marker();
+  Handle<String> append_marker();
+  bool InHoneyPage();
+
+  //
+  // End taint analysis stuff.
+  //
+
  protected:
   explicit Isolate(bool enable_serializer);
   bool IsArrayOrObjectPrototype(Object* object);
@@ -1443,6 +1605,159 @@ class Isolate {
   v8::Isolate::AbortOnUncaughtExceptionCallback
       abort_on_uncaught_exception_callback_;
 
+  /*
+   * Taint analysis stuff.
+   */
+
+  class PersistentHandleData {
+   public:
+    PersistentHandleData()
+        : blocks_(0),
+          next_(NULL),
+          limit_(NULL) {}
+
+    ~PersistentHandleData() {
+      for (int i = 0; i < blocks_.length(); i++)
+        DeleteArray(blocks_[i]);
+    }
+
+    Object **CreateHandle(Object *value) {
+      Object **result = next_;
+      if (result == limit_) {
+        // Ask V8 for a new block of free handles.
+        result = NewArray<internal::Object*>(kHandleBlockSize);
+        blocks_.Add(result);
+        limit_ = &result[kHandleBlockSize];
+      }
+      *result = value;
+      next_ = result + 1;
+      return result;
+    }
+
+    void Iterate(ObjectVisitor *v) {
+      // All blocks except the last one are full.
+      for (int i = 0; i < blocks_.length() - 1; i++) {
+        Object **block = blocks_.at(i);
+        v->VisitPointers(block, &block[kHandleBlockSize]);
+      }
+      // Iterate over live handles in the last block.
+      if (!blocks_.is_empty())
+        v->VisitPointers(blocks_.last(), next_);
+    }
+
+    static void IterateHandles(void *key, void *value, void *data) {
+      PersistentHandleData *handle_data = (PersistentHandleData *)(value);
+      ObjectVisitor *visitor = static_cast<ObjectVisitor *>(data);
+      handle_data->Iterate(visitor);
+    }
+
+   private:
+    const int kHandleBlockSize = v8::internal::KB - 2;
+    List<internal::Object **> blocks_;
+    Object **next_;
+    Object **limit_;
+  };
+
+  commons::HashTable persistent_handle_table_;
+  void *persistent_handle_lookup_;
+  PersistentHandleData *persistent_handle_data_;
+
+  static void IterateDestroyQueuedValues(void *key, void *value, void *data);
+  commons::HashTable values_to_destroy_;
+
+  void DisposeCompilationInfo(CompilationInfo *info);
+  static void AstCacheValueDestructor(Isolate *isolate, void *value);
+  static void IterateScopeDFGDestructor(void *key, void *value, void *data);
+  static void IterateScopeAndNodeDestructor(void *key, void *value, void *data);
+  static void IterateScopeAndNodeInnerDestructor(void *key,
+                                                 void *value, void *data);
+
+  void MakeASTPermanent(Handle<JSFunction> function);
+
+  V8GCHashTable *permanent_ast_cache_;
+  V8GCHashTable *ast_cache_;
+
+  int hit_count_;
+  int lookup_count_;
+
+  // Cascade value destructor from |ast_cache_|.
+  commons::HashTable scope_dfg_cache_;
+  commons::HashTable located_scope_and_node_cache_;
+
+  static void TaintTableValueDestructor(Isolate *isolate, void *value);
+  V8GCHashTable *taint_table_;
+
+  V8GCHashTable *do_not_taint_;
+
+  commons::HashTable ast_taint_table_;
+
+  commons::HashTable object_map_;  // For Property and Call.
+
+  V8GCHashTable *extension_contexts_;
+  V8GCHashTable *tainted_js_functions_;
+  V8GCHashTable *taint_source_objects_;
+  V8GCHashTable *taint_sources_;
+
+#ifndef DISABLE_PROPAGATION_REPORT
+
+  struct PropagatedFrom {
+    enum FromNodeType { ASTNODE, PSEUDO };
+    FromNodeType from_type;
+    Handle<JSFunction> function;
+    Handle<Object> from_obj;
+  };
+
+  static void * const ipc_pseudo_node_;
+
+  void AddPropagatedFromCommon(Handle<Object> obj,
+                               Handle<JSFunction> function,
+                               void *from_node,
+                               PropagatedFrom::FromNodeType from_type,
+                               Handle<Object> from_obj);
+
+  static void IteratePrintPropagationPrev(void *key, void *value, void *data);
+  static void IteratePrintPropagationPath(void *key, void *value, void *data);
+  void DoPrintPropagationPath(Handle<Object> obj);
+
+  static void IteratePrintTaintSourceObjects(void *key,
+                                             void *value,
+                                             void *data);
+
+  static void IteratePrintPropagationPathFunctions(void *key,
+                                                   void *value,
+                                                   void *data);
+
+  static void IteratePrintTaintSourceFunctions(void *key,
+                                               void *value,
+                                               void *data);
+
+  static void IteratePropagatedFromDestructor(void *key,
+                                              void *value,
+                                              void *data);
+
+  static void PropagatedFromValueDestructor(Isolate *isolate, void *value);
+
+  V8GCHashTable *propagated_from_;
+
+  Object *propagates_to_;
+  commons::HashTable propagation_path_objects_;
+  commons::HashTable propagation_path_functions_;
+
+  void CollectPropagationPaths(Handle<Object> obj);
+  std::stringstream propagation_paths_ss_;
+
+#endif  // DISABLE_PROPAGATION_REPORT
+
+  V8GCHashTable *do_not_propagate_;
+  V8GCHashTable *do_not_propagate_functions_;
+
+  Handle<String> prepend_marker_;
+  Handle<String> append_marker_;
+
+  /*
+   * End taint analysis stuff.
+   */
+
   friend class ExecutionAccess;
   friend class HandleScopeImplementer;
   friend class OptimizingCompileDispatcher;
diff --git a/src/js/array.js b/src/js/array.js
index d10e7f18b5..e6b3e41311 100644
--- a/src/js/array.js
+++ b/src/js/array.js
@@ -386,7 +386,12 @@ function ArrayJoin(separator) {
   var array = TO_OBJECT(this);
   var length = TO_LENGTH(array.length);
 
-  return InnerArrayJoin(separator, array, length);
+  var result = InnerArrayJoin(separator, array, length);
+  if (this.containsTaintedValue()) {
+    result.setTaint();
+    result.setPropagationPaths(this.getAllPropagationPaths());
+  }
+  return result;
 }
 
 
diff --git a/src/js/regexp.js b/src/js/regexp.js
index dbe4837c64..f24f148ad4 100644
--- a/src/js/regexp.js
+++ b/src/js/regexp.js
@@ -133,6 +133,7 @@ function RegExpCompileJS(pattern, flags) {
 
 
 function DoRegExpExec(regexp, string, index) {
+  RegExpLastMatchInfo.resetTaint();
   return %_RegExpExec(regexp, string, index, RegExpLastMatchInfo);
 }
 
@@ -164,6 +165,7 @@ endmacro
 
 
 function RegExpExecNoTests(regexp, string, start) {
+  RegExpLastMatchInfo.resetTaint();
   // Must be called with RegExp, string and positive integer as arguments.
   var matchInfo = %_RegExpExec(regexp, string, start, RegExpLastMatchInfo);
   if (matchInfo !== null) {
@@ -179,6 +181,8 @@ function RegExpExecNoTests(regexp, string, start) {
 // ES#sec-regexp.prototype.exec
 // RegExp.prototype.exec ( string )
 function RegExpSubclassExecJS(string) {
+  RegExpLastMatchInfo.resetTaint();
+
   if (!IS_REGEXP(this)) {
     throw %make_type_error(kIncompatibleMethodReceiver,
                         'RegExp.prototype.exec', this);
@@ -225,6 +229,7 @@ function RegExpSubclassExecJS(string) {
 
 // Legacy implementation of RegExp.prototype.exec
 function RegExpExecJS(string) {
+  RegExpLastMatchInfo.resetTaint();
   if (!IS_REGEXP(this)) {
     throw %make_type_error(kIncompatibleMethodReceiver,
                         'RegExp.prototype.exec', this);
@@ -292,6 +297,7 @@ var regexp_val;
 // means the original value of String.prototype.exec, which is what everybody
 // else implements.
 function RegExpTest(string) {
+  RegExpLastMatchInfo.resetTaint();
   if (!IS_REGEXP(this)) {
     throw %make_type_error(kIncompatibleMethodReceiver,
                         'RegExp.prototype.test', this);
@@ -582,6 +588,7 @@ var reusableReplaceArray = new InternalArray(4);
 // Helper function for replacing regular expressions with the result of a
 // function application in String.prototype.replace.
 function StringReplaceGlobalRegExpWithFunction(subject, regexp, replace) {
+  RegExpLastMatchInfo.resetTaint();
   var resultArray = reusableReplaceArray;
   if (resultArray) {
     reusableReplaceArray = null;
@@ -699,6 +706,7 @@ function StringReplaceNonGlobalRegExpWithFunction(subject, regexp, replace) {
 
 
 function RegExpReplace(string, replace) {
+  RegExpLastMatchInfo.resetTaint();
   if (!IS_REGEXP(this)) {
     throw %make_type_error(kIncompatibleMethodReceiver,
                         "RegExp.prototype.@@replace", this);
@@ -960,6 +968,7 @@ function RegExpSubclassSearch(string) {
 // on the captures array of the last successful match and the subject string
 // of the last successful match.
 function RegExpGetLastMatch() {
+  RegExpLastMatchInfo.resetTaint();
   var regExpSubject = LAST_SUBJECT(RegExpLastMatchInfo);
   return %_SubString(regExpSubject,
                      RegExpLastMatchInfo[CAPTURE0],
@@ -968,6 +977,7 @@ function RegExpGetLastMatch() {
 
 
 function RegExpGetLastParen() {
+  RegExpLastMatchInfo.resetTaint();
   var length = NUMBER_OF_CAPTURES(RegExpLastMatchInfo);
   if (length <= 2) return '';  // There were no captures.
   // We match the SpiderMonkey behavior: return the substring defined by the
@@ -984,6 +994,7 @@ function RegExpGetLastParen() {
 
 
 function RegExpGetLeftContext() {
+  RegExpLastMatchInfo.resetTaint();
   var start_index;
   var subject;
   start_index = RegExpLastMatchInfo[CAPTURE0];
@@ -993,6 +1004,7 @@ function RegExpGetLeftContext() {
 
 
 function RegExpGetRightContext() {
+  RegExpLastMatchInfo.resetTaint();
   var start_index;
   var subject;
   start_index = RegExpLastMatchInfo[CAPTURE1];
@@ -1006,6 +1018,7 @@ function RegExpGetRightContext() {
 // called with indices from 1 to 9.
 function RegExpMakeCaptureGetter(n) {
   return function foo() {
+    RegExpLastMatchInfo.resetTaint();
     var index = n * 2;
     if (index >= NUMBER_OF_CAPTURES(RegExpLastMatchInfo)) return '';
     var matchStart = RegExpLastMatchInfo[CAPTURE(index)];
@@ -1159,10 +1172,12 @@ utils.InstallGetter(GlobalRegExp.prototype, 'unicode', RegExpGetUnicode);
 // value is set the value it is set to is coerced to a string.
 // Getter and setter for the input.
 var RegExpGetInput = function() {
+  RegExpLastMatchInfo.resetTaint();
   var regExpInput = LAST_INPUT(RegExpLastMatchInfo);
   return IS_UNDEFINED(regExpInput) ? "" : regExpInput;
 };
 var RegExpSetInput = function(string) {
+  RegExpLastMatchInfo.resetTaint();
   LAST_INPUT(RegExpLastMatchInfo) = TO_STRING(string);
 };
 
diff --git a/src/js/string.js b/src/js/string.js
index 38caab7b12..20b8d2ee27 100644
--- a/src/js/string.js
+++ b/src/js/string.js
@@ -362,6 +362,7 @@ function StringSlice(start, end) {
 function StringSplitJS(separator, limit) {
   CHECK_OBJECT_COERCIBLE(this, "String.prototype.split");
 
+  // TODO: Handle this case too. Probably the case for regex separator.
   if (!IS_NULL_OR_UNDEFINED(separator)) {
     var splitter = separator[splitSymbol];
     if (!IS_UNDEFINED(splitter)) {
@@ -419,7 +420,7 @@ function StringSubstring(start, end) {
     }
   }
 
-  return %_SubString(s, start_i, end_i);
+  return %SubString(s, start_i, end_i);
 }
 
 
@@ -435,7 +436,7 @@ function StringSubstr(start, length) {
   length = MinSimple(MaxSimple(length, 0), size - start);
 
   if (length <= 0) return '';
-  return %_SubString(s, start, start + length);
+  return %SubString(s, start, start + length);
 }
 
 
@@ -723,6 +724,11 @@ function StringRaw(callSite) {
   return result;
 }
 
+
+function StringIsTaintedAt(pos) {
+  return %TaintAnalysis_StringIsTaintedAt(this, pos);
+}
+
 // -------------------------------------------------------------------
 
 // Set up the non-enumerable functions on the String object.
@@ -753,6 +759,7 @@ utils.InstallFunctions(GlobalString.prototype, DONT_ENUM, [
   "toLocaleLowerCase", StringToLocaleLowerCase,
   "toUpperCase", StringToUpperCaseJS,
   "toLocaleUpperCase", StringToLocaleUpperCase,
+  "isTaintedAt", StringIsTaintedAt,
 
   "link", StringLink,
   "anchor", StringAnchor,
diff --git a/src/js/v8natives.js b/src/js/v8natives.js
index 0c0a7925b9..397e6e6b29 100644
--- a/src/js/v8natives.js
+++ b/src/js/v8natives.js
@@ -15,6 +15,8 @@ var iteratorSymbol = utils.ImportNow("iterator_symbol");
 var NaN = %GetRootNaN();
 var ObjectToString = utils.ImportNow("object_to_string");
 
+var GlobalJSON = global.JSON;
+
 // ----------------------------------------------------------------------------
 
 
@@ -171,6 +173,155 @@ function ObjectConstructor(x) {
 }
 
 
+//Iterate the object and taint everything it contains.
+function SetTaintForAll(report) {
+  var visited = [];  // Cycle avoidance.
+
+  function DoSetTaintForAll(obj, report) {
+    if (obj == null || obj == UNDEFINED)
+      return;
+
+    if (report["tainted"])
+      obj.setTaint();
+    if (report["details"])
+      %TaintAnalysis_SetPropagationPaths(obj, report["details"]);
+
+    visited.push(obj);
+    if (typeof(obj) == "string")
+      return;  // Don't recurse into array indices.
+
+    for (var property in obj) {
+      if (!obj.hasOwnProperty(property))
+        continue;
+
+      /*
+      if (!visited.includes(property)) {
+        CollectObjectsRecursive(property);
+      }
+      */
+      if (!visited.includes(obj[property]) && report["recursive"][property]) {
+        DoSetTaintForAll(obj[property], report["recursive"][property]);
+      }
+    }
+  }
+
+  DoSetTaintForAll(this, GlobalJSON.parse(report));
+}
+
+
+// Iterate the object and check whether it contains any tainted object.
+function ContainsTaintedValue() {
+  var visited = [];  // Cycle avoidance.
+  function ContainsTaintedValueRecursive(obj) {
+    if (obj.isTainted())
+      return true;
+
+    visited.push(obj);
+    if (typeof(obj) == "string")
+      return;  // Don't recurse into array indices.
+
+    for (var property in obj) {
+      if (!obj.hasOwnProperty(property))
+        continue;
+
+      /*
+      if (!visited.includes(property) &&
+          ContainsTaintedValueRecursive(property)) {
+        return true;
+      }
+      */
+      if (!visited.includes(obj[property]) &&
+          ContainsTaintedValueRecursive(obj[property])) {
+        return true;
+      }
+    }
+
+    return false;
+  }
+
+  return ContainsTaintedValueRecursive(this);
+}
+
+
+function GetPropagationPaths() {
+  return %TaintAnalysis_GetPropagationPaths(this);
+}
+
+
+function GetAllPropagationPaths() {
+  var visited = [];
+  var report = {};
+
+  function DoGetAllPropagationPaths(obj, report) {
+    if (obj == null || obj == UNDEFINED)
+      return;
+
+    var obj_report = obj.getPropagationPaths();
+    report["tainted"] = obj.isTainted();
+    report["details"] = obj_report;
+    report["recursive"] = {};
+
+    visited.push(obj);
+    if (typeof(obj) == "string")
+      return;  // Don't recurse into array indices.
+
+    for (var property in obj) {
+      if (!obj.hasOwnProperty(property))
+        continue;
+
+      /*
+      if (!visited.includes(property)) {
+        DoGetAllPropagationPaths(property);
+      }
+      */
+      if (!visited.includes(obj[property])) {
+        report["recursive"][property] = {};
+        DoGetAllPropagationPaths(obj[property], report["recursive"][property]);
+      }
+    }
+  }
+
+  DoGetAllPropagationPaths(this, report);
+  return GlobalJSON.stringify(report);
+}
+
+
+function SetPropagationPaths(report) {
+  %TaintAnalysis_SetPropagationPaths(this, report);
+}
+
+
+function SetTaintSourceForAll(func) {
+  var visited = [];
+
+  function DoSetTaintSourceForAll(obj, func) {
+    if (obj == null || obj == UNDEFINED)
+      return;
+
+    if (obj.isTainted())
+      obj.setAsTaintSource(func);
+
+    visited.push(obj);
+    if (typeof(obj) == "string")
+      return;  // Don't recurse into array indices.
+
+    for (var property in obj) {
+      if (!obj.hasOwnProperty(property))
+        continue;
+
+      /*
+      if (!visited.includes(property))
+        DoSetTaintSourceForAll(property, func);
+      */
+      if (!visited.includes(obj[property]))
+        DoSetTaintSourceForAll(obj[property], func);
+    }
+  }
+
+  DoSetTaintSourceForAll(this, func);
+}
+
+
 // ----------------------------------------------------------------------------
 // Object
 
@@ -186,6 +337,12 @@ utils.InstallFunctions(GlobalObject.prototype, DONT_ENUM, [
   "toLocaleString", ObjectToLocaleString,
   "valueOf", ObjectValueOf,
   "isPrototypeOf", ObjectIsPrototypeOf,
+  "setTaintForAll", SetTaintForAll,
+  "containsTaintedValue", ContainsTaintedValue,
+  "getPropagationPaths", GetPropagationPaths,
+  "getAllPropagationPaths", GetAllPropagationPaths,
+  "setPropagationPaths", SetPropagationPaths,
+  "setTaintSourceForAll", SetTaintSourceForAll,
   // propertyIsEnumerable is added in bootstrapper.cc.
   // __defineGetter__ is added in bootstrapper.cc.
   // __lookupGetter__ is added in bootstrapper.cc.
@@ -203,6 +360,31 @@ utils.InstallFunctions(GlobalObject, DONT_ENUM, [
 ]);
 
 
+// ----------------------------------------------------------------------------
+// JSON
+
+function JsonParse() {
+  return %TaintAnalysis_JsonParse(arguments[0], arguments[1]);
+}
+
+
+function JsonStringify() {
+  var result = %TaintAnalysis_JsonStringify(arguments[0],
+      arguments[1], arguments[2]);
+  if (arguments[0] && arguments[0].containsTaintedValue()) {
+    var report = arguments[0].getAllPropagationPaths();
+    result.setTaint();
+    result.setPropagationPaths(report);
+  }
+  return result;
+}
+
+
+utils.InstallFunctions(GlobalJSON, DONT_ENUM, [
+  "parse", JsonParse,
+  "stringify", JsonStringify,
+]);
+
 
 // ----------------------------------------------------------------------------
 // Number
diff --git a/src/objects-body-descriptors-inl.h b/src/objects-body-descriptors-inl.h
index ccee37b962..620b56a3c9 100644
--- a/src/objects-body-descriptors-inl.h
+++ b/src/objects-body-descriptors-inl.h
@@ -249,7 +249,9 @@ template <JSWeakCollection::BodyVisitingPolicy body_visiting_policy>
 class JSWeakCollection::BodyDescriptorImpl final : public BodyDescriptorBase {
  public:
   STATIC_ASSERT(kTableOffset + kPointerSize == kNextOffset);
-  STATIC_ASSERT(kNextOffset + kPointerSize == kSize);
+  STATIC_ASSERT(kNextOffset + kPointerSize == kPointerMapFlagOffset);
+  STATIC_ASSERT(kPointerMapFlagOffset + kPointerSize == kValueDestructorOffset);
+  STATIC_ASSERT(kValueDestructorOffset + kPointerSize == kSize);
 
   static bool IsValidSlot(HeapObject* obj, int offset) {
     return IsValidSlotImpl(obj, offset);
diff --git a/src/objects-inl.h b/src/objects-inl.h
index 3d82bf8205..49ad53f556 100644
--- a/src/objects-inl.h
+++ b/src/objects-inl.h
@@ -3260,6 +3260,7 @@ CAST_ACCESSOR(NameDictionary)
 CAST_ACCESSOR(NormalizedMapCache)
 CAST_ACCESSOR(Object)
 CAST_ACCESSOR(ObjectHashTable)
+CAST_ACCESSOR(ObjectPointerHashTable)
 CAST_ACCESSOR(ObjectHashSet)
 CAST_ACCESSOR(Oddball)
 CAST_ACCESSOR(OrderedHashMap)
@@ -6584,6 +6585,8 @@ ORDERED_HASH_TABLE_ITERATOR_ACCESSORS(kind, Object, kKindOffset)
 
 ACCESSORS(JSWeakCollection, table, Object, kTableOffset)
 ACCESSORS(JSWeakCollection, next, Object, kNextOffset)
+ACCESSORS(JSWeakCollection, pointer_map_flag, Object, kPointerMapFlagOffset)
+ACCESSORS(JSWeakCollection, value_destructor, Object, kValueDestructorOffset)
 
 
 Address Foreign::foreign_address() {
@@ -7822,8 +7825,16 @@ Handle<Object> ObjectHashTableShape::AsHandle(Isolate* isolate,
 }
 
 
-Handle<ObjectHashTable> ObjectHashTable::Shrink(
-    Handle<ObjectHashTable> table, Handle<Object> key) {
+bool ObjectPointerHashTableShape::IsMatch(Handle<Object> key, Object *other) {
+  if (key.is_null())
+    return false;
+  return *key == other;
+}
+
+
+template <typename Derived, typename Shape>
+Handle<Derived> ObjectHashTableBase<Derived, Shape>::Shrink(
+    Handle<Derived> table, Handle<Object> key) {
   return DerivedHashTable::Shrink(table, key);
 }
 
diff --git a/src/objects.cc b/src/objects.cc
index 00721c2d1b..929635a15e 100644
--- a/src/objects.cc
+++ b/src/objects.cc
@@ -1903,7 +1903,10 @@ Object* GetSimpleHash(Object* object) {
     uint32_t hash = Simd128Value::cast(object)->Hash();
     return Smi::FromInt(hash & Smi::kMaxValue);
   }
-  DCHECK(object->IsJSReceiver());
+  // Disabling this check since GetSimpleHash() is only called in
+  // the GetHash() and GetOrCreateHash(), and we handled the non-JSReceiver
+  // cases there.
+  //DCHECK(object->IsJSReceiver());
   // Simply return the receiver as it is guaranteed to not be a SMI.
   return object;
 }
@@ -1914,6 +1917,26 @@ Object* Object::GetHash() {
   Object* hash = GetSimpleHash(this);
   if (hash->IsSmi()) return hash;
 
+  if (!this->IsJSReceiver()) {
+    // Do NOT use pointer hash here, since GC can change the memory
+    // address of an object.
+    if (this->IsJSFunction()) {
+      uint32_t hash = ComputeIntegerHash(
+          JSFunction::cast(this)->shared()->SourceSize(), kZeroHashSeed);
+      return Smi::FromInt(hash & Smi::kMaxValue);
+    } else if (this->IsSharedFunctionInfo()) {
+      uint32_t hash = ComputeIntegerHash(
+          SharedFunctionInfo::cast(this)->SourceSize(), kZeroHashSeed);
+      return Smi::FromInt(hash & Smi::kMaxValue);
+    } else if (this->IsContext()) {
+      JSGlobalObject *global_object = Context::cast(this)->global_object();
+      CHECK(global_object->IsJSGlobalObject());
+      return global_object->GetHash();
+    } else {
+      return Smi::FromInt(Smi::kMaxValue);
+    }
+  }
+
   DisallowHeapAllocation no_gc;
   DCHECK(IsJSReceiver());
   JSReceiver* receiver = JSReceiver::cast(this);
@@ -1925,6 +1948,29 @@ Smi* Object::GetOrCreateHash(Isolate* isolate, Handle<Object> object) {
   Object* hash = GetSimpleHash(*object);
   if (hash->IsSmi()) return Smi::cast(hash);
 
+  if (!object->IsJSReceiver()) {
+    // Do NOT use pointer hash here, since GC can change the memory
+    // address of an object.
+    if (object->IsJSFunction()) {
+      uint32_t hash = ComputeIntegerHash(
+          JSFunction::cast(*object)->shared()->SourceSize(), kZeroHashSeed);
+      return Smi::FromInt(hash & Smi::kMaxValue);
+    } else if (object->IsSharedFunctionInfo()) {
+      uint32_t hash = ComputeIntegerHash(
+          SharedFunctionInfo::cast(*object)->SourceSize(), kZeroHashSeed);
+      return Smi::FromInt(hash & Smi::kMaxValue);
+    } else if (object->IsContext()) {
+      JSGlobalObject *global_object = Context::cast(*object)->global_object();
+      CHECK(global_object->IsJSGlobalObject());
+      Isolate *isolate = global_object->GetIsolate();
+      HandleScope scope(isolate);
+      return Object::GetOrCreateHash(isolate,
+          Handle<Object>(Object::cast(global_object), isolate));
+    } else {
+      return Smi::FromInt(Smi::kMaxValue);
+    }
+  }
+
   DCHECK(object->IsJSReceiver());
   return JSReceiver::GetOrCreateIdentityHash(isolate,
                                              Handle<JSReceiver>::cast(object));
@@ -16641,9 +16687,10 @@ template class HashTable<CompilationCacheTable,
                          CompilationCacheShape,
                          HashTableKey*>;
 
-template class HashTable<ObjectHashTable,
-                         ObjectHashTableShape,
-                         Handle<Object> >;
+template class ObjectHashTableBase<ObjectHashTable, ObjectHashTableShape>;
+
+template class ObjectHashTableBase<ObjectPointerHashTable,
+                                   ObjectPointerHashTableShape>;
 
 template class HashTable<WeakHashTable, WeakHashTableShape<2>, Handle<Object> >;
 
@@ -17910,40 +17957,50 @@ Object* Dictionary<Derived, Shape, Key>::SlowReverseLookup(Object* value) {
 }
 
 
-Object* ObjectHashTable::Lookup(Isolate* isolate, Handle<Object> key,
-                                int32_t hash) {
+template <typename Derived, typename Shape>
+Object* ObjectHashTableBase<Derived, Shape>::Lookup(Isolate* isolate,
+                                                    Handle<Object> key,
+                                                    int32_t hash) {
   DisallowHeapAllocation no_gc;
-  DCHECK(IsKey(isolate, *key));
+  DCHECK(DerivedHashTable::IsKey(isolate, *key));
 
-  int entry = FindEntry(isolate, key, hash);
-  if (entry == kNotFound) return isolate->heap()->the_hole_value();
-  return get(EntryToIndex(entry) + 1);
+  int entry = this->FindEntry(isolate, key, hash);
+  if (entry == this->kNotFound)
+    return isolate->heap()->the_hole_value();
+  return this->get(this->EntryToIndex(entry) + 1);
 }
 
 
-Object* ObjectHashTable::Lookup(Handle<Object> key) {
+template <typename Derived, typename Shape>
+Object* ObjectHashTableBase<Derived, Shape>::Lookup(Handle<Object> key) {
   DisallowHeapAllocation no_gc;
 
-  Isolate* isolate = GetIsolate();
-  DCHECK(IsKey(isolate, *key));
+  Isolate* isolate = this->GetIsolate();
+  DCHECK(DerivedHashTable::IsKey(isolate, *key));
 
   // If the object does not have an identity hash, it was never used as a key.
   Object* hash = key->GetHash();
   if (hash->IsUndefined(isolate)) {
     return isolate->heap()->the_hole_value();
   }
-  return Lookup(isolate, key, Smi::cast(hash)->value());
+  return ObjectHashTableBase<Derived, Shape>::Lookup(
+      isolate, key, Smi::cast(hash)->value());
 }
 
 
-Object* ObjectHashTable::Lookup(Handle<Object> key, int32_t hash) {
-  return Lookup(GetIsolate(), key, hash);
+template <typename Derived, typename Shape>
+Object* ObjectHashTableBase<Derived, Shape>::Lookup(Handle<Object> key,
+                                                    int32_t hash) {
+  return ObjectHashTableBase<Derived, Shape>::Lookup(
+      this->GetIsolate(), key, hash);
 }
 
 
-Handle<ObjectHashTable> ObjectHashTable::Put(Handle<ObjectHashTable> table,
-                                             Handle<Object> key,
-                                             Handle<Object> value) {
+template <typename Derived, typename Shape>
+Handle<Derived> ObjectHashTableBase<Derived, Shape>::Put(
+    Handle<Derived> table,
+    Handle<Object> key,
+    Handle<Object> value) {
   Isolate* isolate = table->GetIsolate();
   DCHECK(table->IsKey(isolate, *key));
   DCHECK(!value->IsTheHole(isolate));
@@ -17955,10 +18012,12 @@ Handle<ObjectHashTable> ObjectHashTable::Put(Handle<ObjectHashTable> table,
 }
 
 
-Handle<ObjectHashTable> ObjectHashTable::Put(Handle<ObjectHashTable> table,
-                                             Handle<Object> key,
-                                             Handle<Object> value,
-                                             int32_t hash) {
+template <typename Derived, typename Shape>
+Handle<Derived> ObjectHashTableBase<Derived, Shape>::Put(
+    Handle<Derived> table,
+    Handle<Object> key,
+    Handle<Object> value,
+    int32_t hash) {
   Isolate* isolate = table->GetIsolate();
   DCHECK(table->IsKey(isolate, *key));
   DCHECK(!value->IsTheHole(isolate));
@@ -17966,8 +18025,8 @@ Handle<ObjectHashTable> ObjectHashTable::Put(Handle<ObjectHashTable> table,
   int entry = table->FindEntry(isolate, key, hash);
 
   // Key is already in table, just overwrite value.
-  if (entry != kNotFound) {
-    table->set(EntryToIndex(entry) + 1, *value);
+  if (entry != DerivedHashTable::kNotFound) {
+    table->set(DerivedHashTable::EntryToIndex(entry) + 1, *value);
     return table;
   }
 
@@ -17980,8 +18039,8 @@ Handle<ObjectHashTable> ObjectHashTable::Put(Handle<ObjectHashTable> table,
   // isn't enough to avoid a crash.
   if (!table->HasSufficientCapacityToAdd(1)) {
     int nof = table->NumberOfElements() + 1;
-    int capacity = ObjectHashTable::ComputeCapacity(nof * 2);
-    if (capacity > ObjectHashTable::kMaxCapacity) {
+    int capacity = ObjectHashTableBase::ComputeCapacity(nof * 2);
+    if (capacity > ObjectHashTableBase::kMaxCapacity) {
       for (size_t i = 0; i < 2; ++i) {
         isolate->heap()->CollectAllGarbage(
             Heap::kFinalizeIncrementalMarkingMask, "full object hash table");
@@ -17991,15 +18050,17 @@ Handle<ObjectHashTable> ObjectHashTable::Put(Handle<ObjectHashTable> table,
   }
 
   // Check whether the hash table should be extended.
-  table = EnsureCapacity(table, 1, key);
+  table = DerivedHashTable::EnsureCapacity(table, 1, key);
   table->AddEntry(table->FindInsertionEntry(hash), *key, *value);
   return table;
 }
 
 
-Handle<ObjectHashTable> ObjectHashTable::Remove(Handle<ObjectHashTable> table,
-                                                Handle<Object> key,
-                                                bool* was_present) {
+template <typename Derived, typename Shape>
+Handle<Derived> ObjectHashTableBase<Derived, Shape>::Remove(
+    Handle<Derived> table,
+    Handle<Object> key,
+    bool* was_present) {
   DCHECK(table->IsKey(table->GetIsolate(), *key));
 
   Object* hash = key->GetHash();
@@ -18012,15 +18073,17 @@ Handle<ObjectHashTable> ObjectHashTable::Remove(Handle<ObjectHashTable> table,
 }
 
 
-Handle<ObjectHashTable> ObjectHashTable::Remove(Handle<ObjectHashTable> table,
-                                                Handle<Object> key,
-                                                bool* was_present,
-                                                int32_t hash) {
+template <typename Derived, typename Shape>
+Handle<Derived> ObjectHashTableBase<Derived, Shape>::Remove(
+    Handle<Derived> table,
+    Handle<Object> key,
+    bool* was_present,
+    int32_t hash) {
   Isolate* isolate = table->GetIsolate();
   DCHECK(table->IsKey(isolate, *key));
 
   int entry = table->FindEntry(isolate, key, hash);
-  if (entry == kNotFound) {
+  if (entry == DerivedHashTable::kNotFound) {
     *was_present = false;
     return table;
   }
@@ -18031,18 +18094,120 @@ Handle<ObjectHashTable> ObjectHashTable::Remove(Handle<ObjectHashTable> table,
 }
 
 
-void ObjectHashTable::AddEntry(int entry, Object* key, Object* value) {
-  set(EntryToIndex(entry), key);
-  set(EntryToIndex(entry) + 1, value);
-  ElementAdded();
+template <typename Derived, typename Shape>
+void ObjectHashTableBase<Derived, Shape>::AddEntry(int entry,
+                                                   Object* key,
+                                                   Object* value) {
+  this->set(this->EntryToIndex(entry), key);
+  this->set(this->EntryToIndex(entry) + 1, value);
+  this->ElementAdded();
 }
 
 
-void ObjectHashTable::RemoveEntry(int entry) {
-  set_the_hole(EntryToIndex(entry));
-  set_the_hole(EntryToIndex(entry) + 1);
-  ElementRemoved();
-}
+template <typename Derived, typename Shape>
+void ObjectHashTableBase<Derived, Shape>::RemoveEntry(int entry) {
+  this->set_the_hole(this->EntryToIndex(entry));
+  this->set_the_hole(this->EntryToIndex(entry) + 1);
+  this->ElementRemoved();
+}
+
+
+// Force instantiation of ObjectHashTable.
+
+template Object* ObjectHashTableBase<
+    ObjectHashTable,
+    ObjectHashTableShape>::Lookup(Handle<Object> key);
+
+template Object* ObjectHashTableBase<
+    ObjectHashTable,
+    ObjectHashTableShape>::Lookup(Handle<Object> key, int32_t hash);
+
+template Object* ObjectHashTableBase<
+    ObjectHashTable,
+    ObjectHashTableShape>::Lookup(Isolate* isolate,
+                                  Handle<Object> key, int32_t hash);
+
+template Handle<ObjectHashTable> ObjectHashTableBase<
+    ObjectHashTable,
+    ObjectHashTableShape>::Put(Handle<ObjectHashTable> table,
+                               Handle<Object> key,
+                               Handle<Object> value);
+
+template Handle<ObjectHashTable> ObjectHashTableBase<
+    ObjectHashTable,
+    ObjectHashTableShape>::Put(Handle<ObjectHashTable> table,
+                               Handle<Object> key, Handle<Object> value,
+                               int32_t hash);
+
+template Handle<ObjectHashTable> ObjectHashTableBase<
+    ObjectHashTable,
+    ObjectHashTableShape>::Remove(Handle<ObjectHashTable> table,
+                                  Handle<Object> key,
+                                  bool* was_present);
+
+template Handle<ObjectHashTable> ObjectHashTableBase<
+    ObjectHashTable,
+    ObjectHashTableShape>::Remove(Handle<ObjectHashTable> table,
+                                  Handle<Object> key, bool* was_present,
+                                  int32_t hash);
+
+template void ObjectHashTableBase<
+    ObjectHashTable,
+    ObjectHashTableShape>::AddEntry(int entry, Object* key, Object* value);
+
+template void ObjectHashTableBase<
+    ObjectHashTable,
+    ObjectHashTableShape>::RemoveEntry(int entry);
+
+
+// Force instantiation of ObjectPointerHashTable.
+
+template Object* ObjectHashTableBase<
+    ObjectPointerHashTable,
+    ObjectPointerHashTableShape>::Lookup(Handle<Object> key);
+
+template Object* ObjectHashTableBase<
+    ObjectPointerHashTable,
+    ObjectPointerHashTableShape>::Lookup(Handle<Object> key, int32_t hash);
+
+template Object* ObjectHashTableBase<
+    ObjectPointerHashTable,
+    ObjectPointerHashTableShape>::Lookup(Isolate* isolate,
+                                  Handle<Object> key, int32_t hash);
+
+template Handle<ObjectPointerHashTable> ObjectHashTableBase<
+    ObjectPointerHashTable,
+    ObjectPointerHashTableShape>::Put(Handle<ObjectPointerHashTable> table,
+                                      Handle<Object> key,
+                                      Handle<Object> value);
+
+template Handle<ObjectPointerHashTable> ObjectHashTableBase<
+    ObjectPointerHashTable,
+    ObjectPointerHashTableShape>::Put(Handle<ObjectPointerHashTable> table,
+                                      Handle<Object> key, Handle<Object> value,
+                                      int32_t hash);
+
+template Handle<ObjectPointerHashTable> ObjectHashTableBase<
+    ObjectPointerHashTable,
+    ObjectPointerHashTableShape>::Remove(Handle<ObjectPointerHashTable> table,
+                                                Handle<Object> key,
+                                                bool* was_present);
+
+template Handle<ObjectPointerHashTable> ObjectHashTableBase<
+    ObjectPointerHashTable,
+    ObjectPointerHashTableShape>::Remove(Handle<ObjectPointerHashTable> table,
+                                                Handle<Object> key,
+                                                bool* was_present,
+                                                int32_t hash);
+
+template void ObjectHashTableBase<
+    ObjectPointerHashTable,
+    ObjectPointerHashTableShape>::AddEntry(int entry,
+                                           Object* key, Object* value);
+
+template void ObjectHashTableBase<
+    ObjectPointerHashTable,
+    ObjectPointerHashTableShape>::RemoveEntry(int entry);
 
 
 Object* WeakHashTable::Lookup(Handle<HeapObject> key) {
@@ -18442,42 +18607,81 @@ void JSMap::Clear(Handle<JSMap> map) {
 
 
 void JSWeakCollection::Initialize(Handle<JSWeakCollection> weak_collection,
-                                  Isolate* isolate) {
-  Handle<ObjectHashTable> table = ObjectHashTable::New(isolate, 0);
+                                  Isolate* isolate,
+                                  bool is_pointer_map) {
+  Handle<Object> table;
+  if (is_pointer_map) {
+    weak_collection->set_pointer_map_flag(Smi::FromInt(1));  // Non-tagged.
+    table = Handle<Object>::cast(ObjectPointerHashTable::New(isolate, 0));
+  } else {
+    weak_collection->set_pointer_map_flag(Smi::FromInt(0));
+    table = Handle<Object>::cast(ObjectHashTable::New(isolate, 0));
+  }
   weak_collection->set_table(*table);
+  weak_collection->set_value_destructor(Smi::FromInt(0));
 }
 
 
 void JSWeakCollection::Set(Handle<JSWeakCollection> weak_collection,
                            Handle<Object> key, Handle<Object> value,
                            int32_t hash) {
-  DCHECK(key->IsJSReceiver() || key->IsSymbol());
-  Handle<ObjectHashTable> table(
-      ObjectHashTable::cast(weak_collection->table()));
-  DCHECK(table->IsKey(*key));
-  Handle<ObjectHashTable> new_table =
-      ObjectHashTable::Put(table, key, value, hash);
-  weak_collection->set_table(*new_table);
-  if (*table != *new_table) {
-    // Zap the old table since we didn't record slots for its elements.
-    table->FillWithHoles(0, table->length());
+  bool is_pointer_map =
+      (weak_collection->pointer_map_flag() == Smi::FromInt(1));
+  if (is_pointer_map) {
+    Handle<ObjectPointerHashTable> table(
+        ObjectPointerHashTable::cast(weak_collection->table()));
+    DCHECK(table->IsKey(*key));
+    Handle<ObjectPointerHashTable> new_table =
+        ObjectPointerHashTable::Put(table, key, value, hash);
+    weak_collection->set_table(*new_table);
+    if (*table != *new_table) {
+      // Zap the old table since we didn't record slots for its elements.
+      table->FillWithHoles(0, table->length());
+    }
+  } else {
+    DCHECK(key->IsJSReceiver() || key->IsSymbol());
+    Handle<ObjectHashTable> table(
+        ObjectHashTable::cast(weak_collection->table()));
+    DCHECK(table->IsKey(*key));
+    Handle<ObjectHashTable> new_table =
+        ObjectHashTable::Put(table, key, value, hash);
+    weak_collection->set_table(*new_table);
+    if (*table != *new_table) {
+      // Zap the old table since we didn't record slots for its elements.
+      table->FillWithHoles(0, table->length());
+    }
   }
 }
 
 
 bool JSWeakCollection::Delete(Handle<JSWeakCollection> weak_collection,
                               Handle<Object> key, int32_t hash) {
-  DCHECK(key->IsJSReceiver() || key->IsSymbol());
-  Handle<ObjectHashTable> table(
-      ObjectHashTable::cast(weak_collection->table()));
-  DCHECK(table->IsKey(*key));
+  bool is_pointer_map =
+      (weak_collection->pointer_map_flag() == Smi::FromInt(1));
   bool was_present = false;
-  Handle<ObjectHashTable> new_table =
-      ObjectHashTable::Remove(table, key, &was_present, hash);
-  weak_collection->set_table(*new_table);
-  if (*table != *new_table) {
-    // Zap the old table since we didn't record slots for its elements.
-    table->FillWithHoles(0, table->length());
+  if (is_pointer_map) {
+    Handle<ObjectPointerHashTable> table(
+        ObjectPointerHashTable::cast(weak_collection->table()));
+    DCHECK(table->IsKey(*key));
+    Handle<ObjectPointerHashTable> new_table =
+        ObjectPointerHashTable::Remove(table, key, &was_present, hash);
+    weak_collection->set_table(*new_table);
+    if (*table != *new_table) {
+      // Zap the old table since we didn't record slots for its elements.
+      table->FillWithHoles(0, table->length());
+    }
+  } else {
+    DCHECK(key->IsJSReceiver() || key->IsSymbol());
+    Handle<ObjectHashTable> table(
+        ObjectHashTable::cast(weak_collection->table()));
+    DCHECK(table->IsKey(*key));
+    Handle<ObjectHashTable> new_table =
+        ObjectHashTable::Remove(table, key, &was_present, hash);
+    weak_collection->set_table(*new_table);
+    if (*table != *new_table) {
+      // Zap the old table since we didn't record slots for its elements.
+      table->FillWithHoles(0, table->length());
+    }
   }
   return was_present;
 }
diff --git a/src/objects.h b/src/objects.h
index b7c67030c5..08997471d9 100644
--- a/src/objects.h
+++ b/src/objects.h
@@ -3315,6 +3315,7 @@ class HashTable : public HashTableBase {
 
  protected:
   friend class ObjectHashTable;
+  friend class ObjectPointerHashTable;
 
   // Find the entry at which to insert element with the given key that
   // has the given hash value.
@@ -3822,31 +3823,17 @@ class UnseededNumberDictionary
 };
 
 
-class ObjectHashTableShape : public BaseShape<Handle<Object> > {
- public:
-  static inline bool IsMatch(Handle<Object> key, Object* other);
-  static inline uint32_t Hash(Handle<Object> key);
-  static inline uint32_t HashForObject(Handle<Object> key, Object* object);
-  static inline Handle<Object> AsHandle(Isolate* isolate, Handle<Object> key);
-  static const int kPrefixSize = 0;
-  static const int kEntrySize = 2;
-};
-
-
-// ObjectHashTable maps keys that are arbitrary objects to object values by
-// using the identity hash of the key for hashing purposes.
-class ObjectHashTable: public HashTable<ObjectHashTable,
-                                        ObjectHashTableShape,
-                                        Handle<Object> > {
-  typedef HashTable<
-      ObjectHashTable, ObjectHashTableShape, Handle<Object> > DerivedHashTable;
+template <typename Derived, typename Shape>
+class ObjectHashTableBase: public HashTable<Derived,
+                                            Shape,
+                                            Handle<Object> > {
+  typedef HashTable<Derived, Shape, Handle<Object> > DerivedHashTable;
  public:
-  DECLARE_CAST(ObjectHashTable)
+  DECLARE_CAST(ObjectHashTableBase)
 
   // Attempt to shrink hash table after removal of key.
-  MUST_USE_RESULT static inline Handle<ObjectHashTable> Shrink(
-      Handle<ObjectHashTable> table,
-      Handle<Object> key);
+  MUST_USE_RESULT static inline Handle<Derived> Shrink(Handle<Derived> table,
+                                                       Handle<Object> key);
 
   // Looks up the value associated with the given key. The hole value is
   // returned in case the key is not present.
@@ -3855,33 +3842,72 @@ class ObjectHashTable: public HashTable<ObjectHashTable,
   Object* Lookup(Isolate* isolate, Handle<Object> key, int32_t hash);
 
   // Adds (or overwrites) the value associated with the given key.
-  static Handle<ObjectHashTable> Put(Handle<ObjectHashTable> table,
-                                     Handle<Object> key,
-                                     Handle<Object> value);
-  static Handle<ObjectHashTable> Put(Handle<ObjectHashTable> table,
-                                     Handle<Object> key, Handle<Object> value,
-                                     int32_t hash);
+  static Handle<Derived> Put(Handle<Derived> table,
+                             Handle<Object> key,
+                             Handle<Object> value);
+  static Handle<Derived> Put(Handle<Derived> table,
+                             Handle<Object> key, Handle<Object> value,
+                             int32_t hash);
 
   // Returns an ObjectHashTable (possibly |table|) where |key| has been removed.
-  static Handle<ObjectHashTable> Remove(Handle<ObjectHashTable> table,
-                                        Handle<Object> key,
-                                        bool* was_present);
-  static Handle<ObjectHashTable> Remove(Handle<ObjectHashTable> table,
-                                        Handle<Object> key, bool* was_present,
-                                        int32_t hash);
+  static Handle<Derived> Remove(Handle<Derived> table,
+                                Handle<Object> key,
+                                bool* was_present);
+  static Handle<Derived> Remove(Handle<Derived> table,
+                                Handle<Object> key, bool* was_present,
+                                int32_t hash);
 
  protected:
-  friend class MarkCompactCollector;
-
   void AddEntry(int entry, Object* key, Object* value);
   void RemoveEntry(int entry);
 
   // Returns the index to the value of an entry.
   static inline int EntryToValueIndex(int entry) {
-    return EntryToIndex(entry) + 1;
+    return DerivedHashTable::EntryToIndex(entry) + 1;
   }
 };
 
+
+class ObjectHashTableShape : public BaseShape<Handle<Object> > {
+ public:
+  static inline bool IsMatch(Handle<Object> key, Object* other);
+  static inline uint32_t Hash(Handle<Object> key);
+  static inline uint32_t HashForObject(Handle<Object> key, Object* object);
+  static inline Handle<Object> AsHandle(Isolate* isolate, Handle<Object> key);
+  static const int kPrefixSize = 0;
+  static const int kEntrySize = 2;
+};
+
+
+// ObjectHashTable maps keys that are arbitrary objects to object values by
+// using the identity hash of the key for hashing purposes.
+class ObjectHashTable : public ObjectHashTableBase<ObjectHashTable,
+                                                   ObjectHashTableShape> {
+ public:
+  DECLARE_CAST(ObjectHashTable)
+
+  friend class MarkCompactCollector;
+};
+
+
+// Same as ObjectHashTableShape, except match is determined
+// by pointer identity.
+class ObjectPointerHashTableShape : public ObjectHashTableShape {
+ public:
+  static inline bool IsMatch(Handle<Object> key, Object* other);
+};
+
+
+class ObjectPointerHashTable : public ObjectHashTableBase<
+    ObjectPointerHashTable,
+    ObjectPointerHashTableShape> {
+ public:
+  DECLARE_CAST(ObjectPointerHashTable)
+
+  friend class MarkCompactCollector;
+};
+
+
 class ObjectHashSetShape : public ObjectHashTableShape {
  public:
   static const int kPrefixSize = 0;
@@ -10173,7 +10199,16 @@ class JSWeakCollection: public JSObject {
   // [next]: linked list of encountered weak maps during GC.
   DECL_ACCESSORS(next, Object)
 
-  static void Initialize(Handle<JSWeakCollection> collection, Isolate* isolate);
+  // [pointer_map_flag]: whether the backing hash table
+  // is a ObjectPointerHashTable.
+  DECL_ACCESSORS(pointer_map_flag, Object)
+
+  // [value_destructor]: actions to apply on GC delete.
+  DECL_ACCESSORS(value_destructor, Object)
+
+  static void Initialize(Handle<JSWeakCollection> collection,
+                         Isolate* isolate,
+                         bool is_pointer_map = false);
   static void Set(Handle<JSWeakCollection> collection, Handle<Object> key,
                   Handle<Object> value, int32_t hash);
   static bool Delete(Handle<JSWeakCollection> collection, Handle<Object> key,
@@ -10181,7 +10216,10 @@ class JSWeakCollection: public JSObject {
 
   static const int kTableOffset = JSObject::kHeaderSize;
   static const int kNextOffset = kTableOffset + kPointerSize;
-  static const int kSize = kNextOffset + kPointerSize;
+  static const int kPointerMapFlagOffset = kNextOffset + kPointerSize;
+  static const int kValueDestructorOffset =
+      kPointerMapFlagOffset + kPointerSize;
+  static const int kSize = kValueDestructorOffset + kPointerSize;
 
   // Visiting policy defines whether the table and next collection fields
   // should be visited or not.
diff --git a/src/runtime/runtime-object.cc b/src/runtime/runtime-object.cc
index 6d4bad5c6f..932ecad394 100644
--- a/src/runtime/runtime-object.cc
+++ b/src/runtime/runtime-object.cc
@@ -666,6 +666,18 @@ RUNTIME_FUNCTION(Runtime_DefineDataPropertyInLiteral) {
                         isolate->factory()->empty_string());
   }
 
+  /*
+  if (value->IsHeapNumber()) {
+    printf("DefineDataPropertyInLiteral: ");
+    object->Print();
+    printf(" ");
+    name->Print();
+    printf(" ");
+    value->Print();
+    printf("\n");
+  }
+  */
+
   LookupIterator it = LookupIterator::PropertyOrElement(
       isolate, object, name, object, LookupIterator::OWN);
   // Cannot fail since this should only be called when
diff --git a/src/runtime/runtime-regexp.cc b/src/runtime/runtime-regexp.cc
index b36e5e66cb..56b9af7737 100644
--- a/src/runtime/runtime-regexp.cc
+++ b/src/runtime/runtime-regexp.cc
@@ -687,7 +687,7 @@ RUNTIME_FUNCTION(Runtime_StringSplit) {
   int pattern_length = pattern->length();
   CHECK(pattern_length > 0);
 
-  if (limit == 0xffffffffu) {
+  if (limit == 0xffffffffu && !isolate->IsV8ObjectTainted(subject)) {
     FixedArray* last_match_cache_unused;
     Handle<Object> cached_answer(
         RegExpResultsCache::Lookup(isolate->heap(), *subject, *pattern,
@@ -702,6 +702,9 @@ RUNTIME_FUNCTION(Runtime_StringSplit) {
     }
   }
 
+  // Flatten might allocate a new copy.
+  std::vector<bool> *tainted_bytes = isolate->GetStringTaintedBytes(subject);
+
   // The limit can be very large (0xffffffffu), but since the pattern
   // isn't empty, we can never create more parts than ~half the length
   // of the subject.
@@ -741,16 +744,43 @@ RUNTIME_FUNCTION(Runtime_StringSplit) {
     elements->set(0, *subject);
   } else {
     int part_start = 0;
+    bool do_not_taint = false;  // Do not taint the result array.
     FOR_WITH_HANDLE_SCOPE(isolate, int, i = 0, i, i < part_count, i++, {
       int part_end = indices.at(i);
       Handle<String> substring =
           isolate->factory()->NewProperSubString(subject, part_start, part_end);
       elements->set(i, *substring);
+
+      // Fix up tainted bytes.
+      if (tainted_bytes != NULL) {
+        std::vector<bool> element_tainted_bytes;
+        bool element_tainted = false;
+        bool wholly_tainted = true;
+        for (int j = 0; j < substring->length(); j++) {
+          bool byte_tainted = tainted_bytes->at(part_start + j);
+          if (byte_tainted)
+            element_tainted = true;
+          else
+            wholly_tainted = false;
+          element_tainted_bytes.push_back(byte_tainted);
+        }
+        if (element_tainted) {
+          if (wholly_tainted)
+            isolate->SetTaintForV8Object(substring);
+          else
+            isolate->SetTaintForV8Object(substring, element_tainted_bytes);
+        } else {
+          do_not_taint = true;  // If at least one element is not tainted.
+        }
+      }
+
       part_start = part_end + pattern_length;
     });
+    if (do_not_taint)
+      isolate->SetDoNotTaint(result);
   }
 
-  if (limit == 0xffffffffu) {
+  if (limit == 0xffffffffu && !isolate->IsV8ObjectTainted(subject)) {
     if (result->HasFastObjectElements()) {
       RegExpResultsCache::Enter(isolate, subject, pattern, elements,
                                 isolate->factory()->empty_fixed_array(),
diff --git a/src/runtime/runtime-taint.cc b/src/runtime/runtime-taint.cc
new file mode 100644
index 0000000000..d3fd6bdb32
--- /dev/null
+++ b/src/runtime/runtime-taint.cc
@@ -0,0 +1,754 @@
+#include "src/runtime/runtime-taint.h"
+
+#include "src/json-parser.h"
+#include "src/json-stringifier.h"
+
+namespace v8 {
+namespace internal {
+
+#ifdef IGNORE_NON_EXTENSION_CONTEXTS
+// Ignore built-in and non-extension context functions.
+#define IGNORE_NON_PROPAGATION_CONTEXTS(isolate, ignore_builtin, retval)  \
+  do {                                                                    \
+    JavaScriptFrameIterator it(isolate);                                  \
+    Handle<Object> retval_handle(Object::cast(retval), isolate);          \
+    Handle<JSFunction> function(it.frame()->function());                  \
+    if ((ignore_builtin && function->shared()->IsBuiltin()) ||            \
+        !isolate->InExtensionContext(function)) {                         \
+      return (*retval_handle);                                            \
+    }                                                                     \
+  } while (false)
+#else
+// Ignore only built-in functions.
+#define IGNORE_NON_PROPAGATION_CONTEXTS(isolate, ignore_builtin, retval)  \
+  do {                                                                    \
+    JavaScriptFrameIterator it(isolate);                                  \
+    Handle<Object> retval_handle(Object::cast(retval), isolate);          \
+    Handle<JSFunction> function(it.frame()->function());                  \
+    if (ignore_builtin && function->shared()->IsBuiltin()) {              \
+      return (*retval_handle);                                            \
+    }                                                                     \
+  } while (false)
+#endif
+
+#define IGNORE_IF_HONEYPAGE(isolate, retval)                      \
+  do {                                                            \
+    Handle<Object> retval_handle(Object::cast(retval), isolate);  \
+    if (isolate->InHoneyPage())                                   \
+      return *retval_handle;                                      \
+  } while (false)
+
+#define UNDEFINED_VALUE_HEAP  isolate->heap()->undefined_value()
+
+
+// TODO: We don't need per-scope DFGs any more (per function is more natural
+// and would have worked if we didn't resolve variables).
+RUNTIME_FUNCTION(Runtime_TaintAnalysis_OnScopeExit) {
+  CHECK(args.length() == 1);
+  HandleScope handle_scope(isolate);
+
+  IGNORE_NON_PROPAGATION_CONTEXTS(isolate, true, UNDEFINED_VALUE_HEAP);
+  IGNORE_IF_HONEYPAGE(isolate, UNDEFINED_VALUE_HEAP);
+
+  CONVERT_ARG_HANDLE_CHECKED(Smi, position, 0);
+
+  JavaScriptFrameIterator it(isolate);
+  Handle<JSFunction> function(it.frame()->function());
+  CompilationInfo *info = isolate->GetCompilationInfo(function);
+  ScopeDFG *dfg = isolate->GetScopeDFG(info, position->value());
+  if (dfg != NULL)
+    dfg->PropagateTaint(it.frame());
+
+  return UNDEFINED_VALUE_HEAP;
+}
+
+
+// Discard any stale AST TT and OBJMAP that were left behind by
+// a previous function which wasn't properly cleaned up.
+RUNTIME_FUNCTION(Runtime_TaintAnalysis_OnFunctionEnter) {
+  CHECK(args.length() == 0);
+  HandleScope handle_scope(isolate);
+
+  IGNORE_NON_PROPAGATION_CONTEXTS(isolate, true, UNDEFINED_VALUE_HEAP);
+  IGNORE_IF_HONEYPAGE(isolate, UNDEFINED_VALUE_HEAP);
+
+  JavaScriptFrameIterator it(isolate);
+  isolate->DropAstTaintTable(it.frame()->fp());
+  isolate->DropObjectMap(it.frame()->fp());
+
+  return UNDEFINED_VALUE_HEAP;
+}
+
+
+// Taint propagation point for the caller. Also propagates taint for
+// the implicit assignments from the actual argument expressions.
+RUNTIME_FUNCTION(Runtime_TaintAnalysis_OnVisitCallArguments) {
+  CHECK(args.length() == 5);
+  HandleScope handle_scope(isolate);
+
+  IGNORE_NON_PROPAGATION_CONTEXTS(isolate, true, UNDEFINED_VALUE_HEAP);
+  IGNORE_IF_HONEYPAGE(isolate, UNDEFINED_VALUE_HEAP);
+
+  Address last_arg_address = (Address)args[0];
+  CONVERT_ARG_HANDLE_CHECKED(Smi, arg_count, 1);
+  CONVERT_ARG_HANDLE_CHECKED(Smi, scope_position, 3);
+  CONVERT_ARG_HANDLE_CHECKED(Smi, expr_position, 4);
+
+  Handle<JSFunction> callee;
+  if (args[2] != NULL)
+    callee = Handle<JSFunction>(JSFunction::cast(args[2]));
+
+  JavaScriptFrameIterator it(isolate);
+  Handle<JSFunction> function(it.frame()->function());
+
+  // Read before clear (caller and callee might be the same).
+  bool do_not_propagate = DoNotPropagate(isolate);
+  isolate->ClearDoNotPropagate(function);
+
+  if (!callee.is_null() && do_not_propagate) {
+    // Propagate do-not-propagate down the call chain.
+    isolate->AddDoNotPropagate(function, callee);
+  }
+
+  CompilationInfo *info = isolate->GetCompilationInfo(function);
+  ScopeDFG *dfg = isolate->GetScopeDFG(info, scope_position->value());
+  if (dfg != NULL) {
+    if (!dfg->PropagateTaint(it.frame()))
+      return UNDEFINED_VALUE_HEAP; // No tainted values in scope.
+  }
+
+  CallLocator locator(isolate, info->scope(), expr_position->value());
+  locator.Locate(info, info->literal()->body());
+  if (locator.found()) {
+    JQueryRHSChecker j_checker(isolate, locator.LocatedScope());
+    if (j_checker.Check(locator.LocatedNode())) {
+      CHECK(!callee.is_null());
+      isolate->AddDoNotPropagate(function, callee);
+      return UNDEFINED_VALUE_HEAP;
+    }
+
+    ZoneList<Expression *> *args = locator.LocatedNode()->arguments();
+    for (long i = 0; i < args->length(); i++) {
+      ExpressionTaintChecker checker(isolate,
+          locator.LocatedScope(), it.frame());
+      if (checker.Check(args->at(i))) {
+        Object **param_slot = (Object **)(last_arg_address +
+            (arg_count->value() - (1 + i)) * kPointerSize);
+        Handle<Object> obj(*param_slot, isolate);
+        if (obj->IsSmi()) {
+          int value = Smi::cast(*obj)->value();
+          Handle<HeapNumber> heap_number = Handle<HeapNumber>::cast(
+              isolate->factory()->NewHeapNumber(
+                  (double)value, IMMUTABLE, TENURED));
+          CHECK(!isolate->heap()->InNewSpace(*heap_number));
+          // In old space and we disabled incremental marker.
+          *param_slot = *heap_number;
+          obj = heap_number;
+        }
+        isolate->SetTaintForV8Object(obj);
+        checker.PopulatePropagatedFrom(obj);
+      }
+    }
+  }
+
+  return UNDEFINED_VALUE_HEAP;
+}
+
+
+// Taint propagation point for the returning function. Also propagates
+// taint for the implicit assignment from the return value statement.
+RUNTIME_FUNCTION(Runtime_TaintAnalysis_OnVisitReturnStatement) {
+  CHECK(args.length() == 2);
+  HandleScope handle_scope(isolate);
+
+  IGNORE_NON_PROPAGATION_CONTEXTS(isolate, true, UNDEFINED_VALUE_HEAP);
+  IGNORE_IF_HONEYPAGE(isolate, UNDEFINED_VALUE_HEAP);
+
+  CONVERT_ARG_HANDLE_CHECKED(Object, obj, 0);
+  CONVERT_ARG_HANDLE_CHECKED(Smi, position, 1);
+
+  // TODO: Replace the return value if it's Smi.
+  obj = FilterInvalidV8Objects(isolate, obj);
+  if (obj.is_null() || obj->IsSmi() || isolate->IsDoNotTaint(obj))
+    return UNDEFINED_VALUE_HEAP;
+
+  JavaScriptFrameIterator it(isolate);
+  Handle<JSFunction> function(it.frame()->function());
+  CompilationInfo *info = isolate->GetCompilationInfo(function);
+
+  ReturnStatementLocator locator(isolate, info->scope(), position->value());
+  locator.Locate(info, info->literal()->body());
+  if (locator.found()) {
+    ScopeDFG *dfg = isolate->GetScopeDFG(info,
+        locator.LocatedScope()->start_position());
+    if (dfg != NULL)
+      dfg->PropagateTaint(it.frame());
+
+    ExpressionTaintChecker checker(isolate, locator.LocatedScope(), it.frame());
+    if (checker.Check(locator.LocatedNode()->expression())) {
+      isolate->SetTaintForV8Object(obj);
+      checker.PopulatePropagatedFrom(obj);
+    }
+  }
+
+  return UNDEFINED_VALUE_HEAP;
+}
+
+
+RUNTIME_FUNCTION(Runtime_TaintAnalysis_OnReturnFromCall) {
+  CHECK(args.length() == 2);
+  HandleScope handle_scope(isolate);
+
+  IGNORE_NON_PROPAGATION_CONTEXTS(isolate, true, UNDEFINED_VALUE_HEAP);
+  IGNORE_IF_HONEYPAGE(isolate, UNDEFINED_VALUE_HEAP);
+
+  CONVERT_ARG_HANDLE_CHECKED(Object, obj, 0);
+  CONVERT_ARG_HANDLE_CHECKED(Smi, position, 1);
+
+  obj = FilterInvalidV8Objects(isolate, obj);
+  if (obj.is_null())
+    return UNDEFINED_VALUE_HEAP;
+
+  JavaScriptFrameIterator it(isolate);
+
+  if (isolate->IsV8ObjectTainted(obj) &&
+      !isolate->IsV8ObjectPartiallyTainted(obj)) {
+    Handle<JSFunction> function(it.frame()->function());
+    isolate->SetTaintForAstNode(function, it.frame()->fp(),
+        position->value(), AstNode::kCall);
+  }
+
+  isolate->AddToObjectMap(it.frame()->fp(),
+      position->value(), AstNode::kCall, obj);
+
+  return UNDEFINED_VALUE_HEAP;
+}
+
+
+RUNTIME_FUNCTION(Runtime_TaintAnalysis_OnVisitVariableProxy) {
+  CHECK_EQ(args.length(), 3);
+  HandleScope handle_scope(isolate);
+
+  IGNORE_NON_PROPAGATION_CONTEXTS(isolate, true, UNDEFINED_VALUE_HEAP);
+  IGNORE_IF_HONEYPAGE(isolate, UNDEFINED_VALUE_HEAP);
+
+  CONVERT_ARG_HANDLE_CHECKED(Object, obj, 0);
+  CONVERT_ARG_HANDLE_CHECKED(Smi, scope_position, 1);
+  CONVERT_ARG_HANDLE_CHECKED(Smi, expr_position, 2);
+
+  JavaScriptFrameIterator it(isolate);
+  Handle<JSFunction> function(it.frame()->function());
+
+  // Update AST taint.
+  if (isolate->IsV8ObjectTainted(obj) &&
+      !isolate->IsV8ObjectPartiallyTainted(obj)) {
+    isolate->SetTaintForAstNode(function, it.frame()->fp(),
+        expr_position->value(), AstNode::kVariableProxy);
+  } else {
+    isolate->UntaintAstNode(it.frame()->fp(),
+        expr_position->value(), AstNode::kVariableProxy);
+  }
+
+  // Update object map.
+  isolate->AddToObjectMap(it.frame()->fp(),
+      expr_position->value(), AstNode::kVariableProxy, obj);
+
+  return UNDEFINED_VALUE_HEAP;
+}
+
+
+RUNTIME_FUNCTION(Runtime_TaintAnalysis_OnVisitProperty) {
+  CHECK(args.length() == 4);
+  HandleScope handle_scope(isolate);
+
+  IGNORE_NON_PROPAGATION_CONTEXTS(isolate, true, UNDEFINED_VALUE_HEAP);
+  IGNORE_IF_HONEYPAGE(isolate, UNDEFINED_VALUE_HEAP);
+
+  // TODO: Get rid of home object. We don't need it here due to the fact
+  // that we recursively generate DFG edges for the obj expression.
+  CONVERT_ARG_HANDLE_CHECKED(Object, home, 0);
+  CONVERT_ARG_HANDLE_CHECKED(Object, obj, 1);
+  CONVERT_ARG_HANDLE_CHECKED(Smi, scope_position, 2);
+  CONVERT_ARG_HANDLE_CHECKED(Smi, expr_position, 3);
+
+  JavaScriptFrameIterator it(isolate);
+  Handle<JSFunction> function(it.frame()->function());
+
+  // Update AST taint.
+  if (isolate->IsV8ObjectTainted(obj) &&
+      !isolate->IsV8ObjectPartiallyTainted(obj)) {
+    isolate->SetTaintForAstNode(function, it.frame()->fp(),
+        expr_position->value(), AstNode::kProperty);
+  } else {
+    isolate->UntaintAstNode(it.frame()->fp(),
+        expr_position->value(), AstNode::kProperty);
+  }
+
+  // Update object map.
+  isolate->AddToObjectMap(it.frame()->fp(),
+      expr_position->value(), AstNode::kProperty, obj);
+
+  return UNDEFINED_VALUE_HEAP;
+}
+
+
+// Taint propagation point. Also propagates taint for the
+// implicit assignments from the element expressions.
+RUNTIME_FUNCTION(Runtime_TaintAnalysis_OnVisitArrayLiteral) {
+  CHECK(args.length() == 3);
+  HandleScope handle_scope(isolate);
+
+  IGNORE_NON_PROPAGATION_CONTEXTS(isolate, true, UNDEFINED_VALUE_HEAP);
+  IGNORE_IF_HONEYPAGE(isolate, UNDEFINED_VALUE_HEAP);
+
+  CONVERT_ARG_HANDLE_CHECKED(Object, obj, 0);
+  CONVERT_ARG_HANDLE_CHECKED(Smi, scope_position, 1);
+  CONVERT_ARG_HANDLE_CHECKED(Smi, expr_position, 2);
+
+  obj = FilterInvalidV8Objects(isolate, obj);
+  if (obj.is_null())
+    return UNDEFINED_VALUE_HEAP;
+
+  JavaScriptFrameIterator it(isolate);
+  Handle<JSFunction> function(it.frame()->function());
+  CompilationInfo *info = isolate->GetCompilationInfo(function);
+
+  ScopeDFG *dfg = isolate->GetScopeDFG(info, scope_position->value());
+  if (dfg != NULL)
+    dfg->PropagateTaint(it.frame());
+
+  ArrayLiteralLocator locator(isolate, info->scope(), expr_position->value());
+  locator.Locate(info, info->literal()->body());
+  if (locator.found()) {
+    ArrayLiteral *expr = locator.LocatedNode();
+
+    // This will potentially trigger GC!
+    MaybeHandle<FixedArray> maybe_list =
+        Object::CreateListFromArrayLike(isolate, obj, ElementTypes::kAll);
+    isolate->clear_pending_exception();
+
+    if (!maybe_list.is_null()) {
+      Handle<FixedArray> list = maybe_list.ToHandleChecked();
+      CHECK(list->length() == expr->values()->length());
+
+      for (int i = 0; i < list->length(); i++) {
+        Expression *subexpr = expr->values()->at(i);
+        if (CompileTimeValue::IsCompileTimeValue(subexpr))
+          continue;
+
+        ExpressionTaintChecker checker(
+            isolate, locator.LocatedScope(), it.frame());
+        if (checker.Check(subexpr)) {
+          Handle<Object> element = FixedArray::get(*list, i, isolate);
+          element = FilterInvalidV8Objects(isolate, element);
+          // TODO: Can we replace the Smi's here?
+          if (!element.is_null() && !element->IsSmi()) {
+            isolate->SetTaintForV8Object(element);
+            checker.PopulatePropagatedFrom(element);
+          }
+        }
+      }
+    }
+  }
+
+  return UNDEFINED_VALUE_HEAP;
+}
+
+
+// Taint propagation point. Also propagates taint for the
+// implicit assignments from the property expressions.
+//
+// TODO: Is there a way to group the entire object literal
+// into one runtime call (instead of one for each property)?
+RUNTIME_FUNCTION(Runtime_TaintAnalysis_OnVisitObjectLiteral) {
+  CHECK(args.length() == 4);
+  HandleScope handle_scope(isolate);
+
+  IGNORE_NON_PROPAGATION_CONTEXTS(isolate, true, UNDEFINED_VALUE_HEAP);
+  IGNORE_IF_HONEYPAGE(isolate, UNDEFINED_VALUE_HEAP);
+
+  CONVERT_ARG_HANDLE_CHECKED(Object, obj, 0);
+  CONVERT_ARG_HANDLE_CHECKED(Smi, scope_position, 1);
+  CONVERT_ARG_HANDLE_CHECKED(Smi, expr_position, 2);
+  CONVERT_ARG_HANDLE_CHECKED(Smi, index, 3);
+
+  obj = FilterInvalidV8Objects(isolate, obj);
+  if (obj.is_null() || obj->IsSmi())
+    return UNDEFINED_VALUE_HEAP;
+
+  JavaScriptFrameIterator it(isolate);
+  Handle<JSFunction> function(it.frame()->function());
+  CompilationInfo *info = isolate->GetCompilationInfo(function);
+
+  ScopeDFG *dfg = isolate->GetScopeDFG(info, scope_position->value());
+  if (dfg != NULL)
+    dfg->PropagateTaint(it.frame());
+
+  ObjectLiteralLocator locator(isolate, info->scope(), expr_position->value());
+  locator.Locate(info, info->literal()->body());
+  if (locator.found()) {
+    ObjectLiteral *expr = locator.LocatedNode();
+    ObjectLiteral::Property *property = expr->properties()->at(index->value());
+    ExpressionTaintChecker checker(isolate, locator.LocatedScope(), it.frame());
+    if (checker.Check(property->value())) {
+      isolate->SetTaintForV8Object(obj);
+      checker.PopulatePropagatedFrom(obj);
+    }
+  }
+
+  return UNDEFINED_VALUE_HEAP;
+}
+
+
+// Taint propagation point. Top level var initialization is
+// a special runtime call. This is also handled here as an
+// implicit assignment.
+RUNTIME_FUNCTION(Runtime_TaintAnalysis_OnTopLevelVarInitialization) {
+  CHECK(args.length() == 2);
+  HandleScope handle_scope(isolate);
+
+  IGNORE_NON_PROPAGATION_CONTEXTS(isolate, true, UNDEFINED_VALUE_HEAP);
+  IGNORE_IF_HONEYPAGE(isolate, UNDEFINED_VALUE_HEAP);
+
+  CONVERT_ARG_HANDLE_CHECKED(Object, obj, 0);
+  CONVERT_ARG_HANDLE_CHECKED(Smi, position, 1);
+
+  obj = FilterInvalidV8Objects(isolate, obj);
+  // TODO: Replace Smi.
+  if (obj.is_null() || obj->IsSmi())
+    return UNDEFINED_VALUE_HEAP;
+
+  JavaScriptFrameIterator it(isolate);
+  Handle<JSFunction> function(it.frame()->function());
+  CompilationInfo *info = isolate->GetCompilationInfo(function);
+
+  CallRuntimeLocator locator(isolate, info->scope(), position->value());
+  locator.Locate(info, info->literal()->body());
+  if (locator.found()) {
+    Scope *scope = locator.LocatedScope();
+    ScopeDFG *dfg = isolate->GetScopeDFG(info, scope->start_position());
+    if (dfg != NULL)
+      dfg->PropagateTaint(it.frame());
+
+    ExpressionTaintChecker checker(isolate, scope, it.frame());
+    CallRuntime *expr = locator.LocatedNode();
+    if (checker.Check(expr->arguments()->at(2))) {
+      isolate->SetTaintForV8Object(obj);
+      checker.PopulatePropagatedFrom(obj);
+    }
+  }
+
+  return UNDEFINED_VALUE_HEAP;
+}
+
+
+RUNTIME_FUNCTION(Runtime_TaintAnalysis_ReplaceSmiResult) {
+  CHECK(args.length() == 1);
+  HandleScope handle_scope(isolate);
+
+  CONVERT_ARG_HANDLE_CHECKED(Smi, num, 0);
+
+  IGNORE_NON_PROPAGATION_CONTEXTS(isolate, true, *num);
+  IGNORE_IF_HONEYPAGE(isolate, *num);
+
+  JavaScriptFrameIterator it(isolate);
+  Handle<JSFunction> function(it.frame()->function());
+
+  Handle<HeapNumber> heap_number = Handle<HeapNumber>::cast(
+      isolate->factory()->NewHeapNumber((double)(num->value())));
+  return *heap_number;
+}
+
+
+RUNTIME_FUNCTION(Runtime_TaintAnalysis_ReplaceSmiResult2) {
+  CHECK(args.length() == 1);
+  HandleScope handle_scope(isolate);
+
+  CONVERT_ARG_HANDLE_CHECKED(Smi, num, 0);
+
+  IGNORE_NON_PROPAGATION_CONTEXTS(isolate, true, *num);
+  IGNORE_IF_HONEYPAGE(isolate, *num);
+
+  JavaScriptFrameIterator it(isolate);
+  Handle<JSFunction> function(it.frame()->function());
+
+  Handle<HeapNumber> heap_number = Handle<HeapNumber>::cast(
+      isolate->factory()->NewHeapNumber((double)(num->value())));
+  CHECK(!heap_number->IsSmi() && heap_number->IsHeapNumber());
+  heap_number->Print();
+  printf("\n");
+  return *heap_number;
+}
+
+
+RUNTIME_FUNCTION(Runtime_TaintAnalysis_SetTaint) {
+  CHECK(args.length() == 2);
+  HandleScope handle_scope(isolate);
+
+  IGNORE_NON_PROPAGATION_CONTEXTS(isolate, false, UNDEFINED_VALUE_HEAP);
+  IGNORE_IF_HONEYPAGE(isolate, UNDEFINED_VALUE_HEAP);
+
+  CONVERT_ARG_HANDLE_CHECKED(Object, obj, 0);
+  CONVERT_ARG_HANDLE_CHECKED(Smi, position, 1);
+
+  obj = FilterInvalidV8Objects(isolate, obj);
+  if (obj.is_null() || obj->IsSmi())
+    return UNDEFINED_VALUE_HEAP;
+
+  isolate->SetTaintForV8Object(obj);
+
+  JavaScriptFrameIterator it(isolate);
+  Handle<JSFunction> function(it.frame()->function());
+  CompilationInfo *info = isolate->GetCompilationInfo(function);
+  CallLocator locator(isolate, info->scope(), position->value());
+  locator.Locate(info, info->literal()->body());
+  if (locator.found()) {
+    Call *call = locator.LocatedNode();
+    AstNode *target = call->expression()->AsProperty()->obj();
+    // |obj| cannot be partially tainted here. Locator is still used
+    // because we don't know what the node type is.
+    isolate->SetTaintForAstNode(function,
+        it.frame()->fp(), target->position(), target->node_type());
+  }
+
+  return UNDEFINED_VALUE_HEAP;
+}
+
+
+RUNTIME_FUNCTION(Runtime_TaintAnalysis_SetAsTaintSource) {
+  CHECK(args.length() == 2);
+  HandleScope handle_scope(isolate);
+
+  CONVERT_ARG_HANDLE_CHECKED(Object, obj, 0);
+  CONVERT_ARG_HANDLE_CHECKED(JSFunction, function, 1);
+  isolate->SetV8ObjectAsTaintSource(obj, function);
+
+  return UNDEFINED_VALUE_HEAP;
+}
+
+
+RUNTIME_FUNCTION(Runtime_TaintAnalysis_IsTainted) {
+  CHECK(args.length() == 3);
+  HandleScope handle_scope(isolate);
+
+  CONVERT_ARG_HANDLE_CHECKED(Object, obj, 0);
+  CONVERT_ARG_HANDLE_CHECKED(Smi, scope_position, 1);
+  CONVERT_ARG_HANDLE_CHECKED(Smi, expr_position, 2);
+
+  JavaScriptFrameIterator it(isolate);
+  Handle<JSFunction> function(it.frame()->function());
+  CompilationInfo *info = isolate->GetCompilationInfo(function);
+  ScopeDFG *dfg = isolate->GetScopeDFG(info, scope_position->value());
+  if (dfg != NULL)
+    dfg->PropagateTaint(it.frame());
+
+  if (isolate->IsV8ObjectTainted(obj))
+    return isolate->heap()->true_value();
+
+  // TODO: Why is this necessary?
+  CallLocator locator(isolate, info->scope(), expr_position->value());
+  locator.Locate(info, info->literal()->body());
+  if (locator.found()) {
+    Call *call = locator.LocatedNode();
+    AstNode *node = call->expression();
+    if (isolate->IsAstNodeTainted(it.frame()->fp(),
+        node->position(), node->node_type())) {
+      return isolate->heap()->true_value();
+    }
+  }
+
+  return isolate->heap()->false_value();
+}
+
+
+RUNTIME_FUNCTION(Runtime_TaintAnalysis_ResetTaint) {
+  CHECK(args.length() == 3);
+  HandleScope handle_scope(isolate);
+
+  CONVERT_ARG_HANDLE_CHECKED(Object, obj, 0);
+  CONVERT_ARG_HANDLE_CHECKED(Smi, position, 1);
+  CONVERT_ARG_HANDLE_CHECKED(Smi, node_type, 2);
+
+  JavaScriptFrameIterator it(isolate);
+
+  isolate->UntaintV8Object(obj);
+  isolate->UntaintAstNode(it.frame()->fp(),
+      position->value(), node_type->value());
+
+  return UNDEFINED_VALUE_HEAP;
+}
+
+
+RUNTIME_FUNCTION(Runtime_TaintAnalysis_MarkAsTaintSource) {
+  CHECK(args.length() == 1);
+  HandleScope handle_scope(isolate);
+
+  CONVERT_ARG_HANDLE_CHECKED(JSFunction, function, 0);
+
+  CHECK(function->IsJSFunction());
+  isolate->MarkAsTaintSource(function);
+
+  return UNDEFINED_VALUE_HEAP;
+}
+
+
+RUNTIME_FUNCTION(Runtime_TaintAnalysis_GetPropagationPaths) {
+  CHECK(args.length() == 1);
+  HandleScope handle_scope(isolate);
+
+  CONVERT_ARG_HANDLE_CHECKED(Object, obj, 0);
+  if (!isolate->IsV8ObjectTainted(obj))
+    return isolate->heap()->empty_string();
+
+  return *(isolate->GetPropagationPaths(obj));
+}
+
+
+RUNTIME_FUNCTION(Runtime_TaintAnalysis_SetPropagationPaths) {
+  CHECK(args.length() == 2);
+  HandleScope handle_scope(isolate);
+  JavaScriptFrameIterator it(isolate);
+  CONVERT_ARG_HANDLE_CHECKED(Object, obj, 0);
+  CONVERT_ARG_HANDLE_CHECKED(String, report, 1);
+  isolate->AddPropagatedFrom(obj,
+      Handle<JSFunction>(it.frame()->function()), report);
+  return UNDEFINED_VALUE_HEAP;
+}
+
+
+RUNTIME_FUNCTION(Runtime_TaintAnalysis_PrintIsTainted) {
+  CHECK(args.length() == 2);
+  HandleScope handle_scope(isolate);
+
+  CONVERT_ARG_HANDLE_CHECKED(Object, obj, 0);
+  CONVERT_ARG_HANDLE_CHECKED(Smi, scope_position, 1);
+
+  JavaScriptFrameIterator it(isolate);
+  Handle<JSFunction> function(it.frame()->function());
+  CompilationInfo *info = isolate->GetCompilationInfo(function);
+  ScopeDFG *dfg = isolate->GetScopeDFG(info, scope_position->value());
+  if (dfg != NULL)
+    dfg->PropagateTaint(it.frame());
+
+  obj->Print();
+  std::cout << ", isTainted: " << isolate->IsV8ObjectTainted(obj) << "\n";
+
+  return UNDEFINED_VALUE_HEAP;
+}
+
+
+RUNTIME_FUNCTION(Runtime_TaintAnalysis_DoNotPropagate) {
+  CHECK(args.length() == 1);
+  HandleScope handle_scope(isolate);
+
+  CONVERT_ARG_HANDLE_CHECKED(JSFunction, function, 0);
+  isolate->AddDoNotPropagateFunction(function);
+
+  /*
+  PrintJSFunction(function);
+  printf("** IsBuiltin: %d\n", function->shared()->IsBuiltin());
+  printf("** IsApiFunction: %d\n", function->shared()->IsApiFunction());
+  printf("** native: %d\n", function->shared()->native());
+
+  if (function->shared()->script()->IsScript()) {
+    Handle<Script> script(Script::cast(function->shared()->script()));
+    printf("** Script type: %d\n", script->type());
+    Script::GetNameOrSourceURL(script)->Print();
+    printf("\n");
+  }
+  */
+
+  return UNDEFINED_VALUE_HEAP;
+}
+
+
+RUNTIME_FUNCTION(Runtime_TaintAnalysis_JsonParse) {
+  CHECK(args.length() == 2);
+  HandleScope handle_scope(isolate);
+
+  CONVERT_ARG_HANDLE_CHECKED(Object, source, 0);
+  CONVERT_ARG_HANDLE_CHECKED(Object, reviver, 1);
+
+  Handle<String> string;
+  ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, string,
+                                     Object::ToString(isolate, source));
+  string = String::Flatten(string);
+  RETURN_RESULT_OR_FAILURE(
+      isolate, string->IsSeqOneByteString()
+                   ? JsonParser<true>::Parse(isolate, string, reviver)
+                   : JsonParser<false>::Parse(isolate, string, reviver));
+}
+
+
+RUNTIME_FUNCTION(Runtime_TaintAnalysis_JsonStringify) {
+  CHECK(args.length() == 3);
+  HandleScope handle_scope(isolate);
+
+  CONVERT_ARG_HANDLE_CHECKED(Object, object, 0);
+  CONVERT_ARG_HANDLE_CHECKED(Object, replacer, 1);
+  CONVERT_ARG_HANDLE_CHECKED(Object, indent, 2);
+
+  JsonStringifier stringifier(isolate);
+  RETURN_RESULT_OR_FAILURE(isolate,
+                           stringifier.Stringify(object, replacer, indent));
+}
+
+
+RUNTIME_FUNCTION(Runtime_TaintAnalysis_StringIsTaintedAt) {
+  CHECK(args.length() == 2);
+  HandleScope handle_scope(isolate);
+  CONVERT_ARG_HANDLE_CHECKED(String, str, 0);
+  CONVERT_ARG_HANDLE_CHECKED(Smi, idx, 1);
+  if (isolate->IsStringTaintedAt(str, idx->value()))
+    return isolate->heap()->true_value();
+  return isolate->heap()->false_value();
+}
+
+
+RUNTIME_FUNCTION(Runtime_TaintAnalysis_LogTaintSink) {
+  CHECK(args.length() == 3);
+  HandleScope handle_scope(isolate);
+
+  IGNORE_IF_HONEYPAGE(isolate, UNDEFINED_VALUE_HEAP);
+
+  CONVERT_ARG_HANDLE_CHECKED(Object, obj, 0);
+  CONVERT_ARG_HANDLE_CHECKED(String, report, 1);
+  CONVERT_ARG_HANDLE_CHECKED(String, where, 2);
+  if (isolate->IsV8ObjectTainted(obj))
+    isolate->LogTaintSink(obj, report, where);
+  return UNDEFINED_VALUE_HEAP;
+}
+
+
+RUNTIME_FUNCTION(Runtime_TaintAnalysis_IsAstNodeTainted) {
+  CHECK(args.length() == 3);
+  HandleScope handle_scope(isolate);
+  CONVERT_ARG_HANDLE_CHECKED(Object, obj, 0);
+  CONVERT_ARG_HANDLE_CHECKED(Smi, position, 1);
+  CONVERT_ARG_HANDLE_CHECKED(Smi, type, 2);
+  JavaScriptFrameIterator it(isolate);
+  Handle<JSFunction> function(it.frame()->function());
+  obj->Print();
+  printf(", %d, %d, %d, %d\n",
+      position->value(), type->value(),
+      isolate->IsV8ObjectTainted(obj),
+      isolate->IsAstNodeTainted(it.frame()->fp(),
+          position->value(), type->value()));
+  return UNDEFINED_VALUE_HEAP;
+}
+
+
+RUNTIME_FUNCTION(Runtime_TaintAnalysis_IsHeapNumber) {
+  CHECK(args.length() == 1);
+  HandleScope handle_scope(isolate);
+  CONVERT_ARG_HANDLE_CHECKED(Object, obj, 0);
+  printf("IsHeapNumber: ");
+  obj->Print();
+  printf("\n");
+  if (obj->IsHeapNumber())
+    return isolate->heap()->true_value();
+  return isolate->heap()->false_value();
+}
+
+}  // namespace internal
+}  // namespace v8
diff --git a/src/runtime/runtime-taint.h b/src/runtime/runtime-taint.h
new file mode 100644
index 0000000000..a40785683f
--- /dev/null
+++ b/src/runtime/runtime-taint.h
@@ -0,0 +1,1331 @@
+#ifndef V8_RUNTIME_TAINT_H_
+#define V8_RUNTIME_TAINT_H_
+
+#include "src/arguments.h"
+#include "src/frames-inl.h"
+#include "src/parsing/parser.h"
+#include "src/parsing/parse-info.h"
+#include "src/compiler.h"
+#include "src/runtime/runtime-utils.h"
+#include "src/commons.h"
+
+#include <iostream>
+
+namespace v8 {
+namespace internal {
+
+#define IGNORE_NON_EXTENSION_CONTEXTS
+#define DISABLE_PROPAGATION_REPORT
+#define POPULATE_CFG_EDGES
+#define PROPAGATION_PATHS_OUT_DIR  "/ram/analysis/v8logs/"
+
+#define PREPEND_MARKER  "// HONEYPAGE1 Quan Chen is obviously so f'ing awesome!"
+#define APPEND_MARKER   "// HONEYPAGE2 Quan Chen is obviously so f'ing awesome!"
+
+// AST node position is of type int, and I don't think there ever
+// will be more than 2^11 AST node types. So this scheme is fine
+// as long as void * is 8 bytes.
+#define KEY_FROM_POSITION_AND_TYPE(pos, type) \
+    reinterpret_cast<void *>(((unsigned long)pos << 12) | \
+        ((type << 1) & 0xffe))
+
+
+static inline Handle<Object> FilterInvalidV8Objects(Isolate *isolate,
+                                                    Handle<Object> obj) {
+  if (obj.is_null() ||
+      *obj == Smi::FromInt(0) ||
+      *obj == isolate->heap()->null_value() ||
+      *obj == isolate->heap()->undefined_value() ||
+      *obj == isolate->heap()->the_hole_value() ||
+      *obj == isolate->heap()->true_value() ||
+      *obj == isolate->heap()->false_value() ||
+      *obj == isolate->heap()->empty_string()) {
+    return Handle<Object>::null();
+  }
+  return obj;
+}
+
+
+static inline bool DoNotPropagate(Isolate *isolate) {
+  // Is the current function in our whitelist of do-not-propagate functions?
+  JavaScriptFrameIterator it_current(isolate);
+  Handle<JSFunction> current(it_current.frame()->function());
+  if (isolate->IsDoNotPropagateFunction(current))
+    return true;
+
+  // Otherwise do we have any do-not-propagates on the current
+  // call chain (indicated by the do-not-propagate table)?
+  JavaScriptFrameIterator it_caller(isolate);
+  it_caller.Advance();
+  if (!it_caller.done()) {
+    Handle<JSFunction> caller(it_caller.frame()->function());
+    return isolate->IsDoNotPropagate(caller, current);
+  }
+
+  return false;
+}
+
+
+static inline void PrintJSFunction(Handle<JSFunction> function) {
+  Handle<SharedFunctionInfo> shared(function->shared());
+  std::unique_ptr<char[]> name = shared->DebugName()->ToCString();
+  std::cout << name.get() << ":\n";
+  if (shared->HasSourceCode()) {
+    Handle<String> source(String::cast(
+        Script::cast(shared->script())->source()));
+    std::string c_source(source->ToCString().get());
+    std::cout << c_source.substr(shared->start_position(),
+        shared->end_position() - shared->start_position());
+    std::cout << "\n\n";
+  }
+}
+
+
+class ASTVisitor : public AstVisitor<ASTVisitor> {
+ public:
+  ASTVisitor(Isolate *isolate, Scope *scope)
+      : isolate_(isolate),
+        scope_(scope),
+        scope_statements_(NULL),
+        stack_limit_(stack_limit_ = isolate_->stack_guard()->real_climit()) {
+  }
+
+  virtual ~ASTVisitor() { }
+
+  Isolate *isolate() const { return isolate_; }
+
+  Scope *scope() const { return scope_; }
+
+  ZoneList<Statement *> *scope_statements() { return scope_statements_; }
+
+  commons::LinkedList *scope_dependencies() { return &scope_dependencies_; }
+
+  commons::LinkedList *dependency_scopes() { return &dependency_scopes_; }
+
+  class EnterScope {
+   public:
+    EnterScope(ASTVisitor *visitor,
+        Scope *scope, ZoneList<Statement *> *statements)
+        : visitor_(visitor) {
+      saved_scope_ = visitor_->scope_;
+      saved_statements_ = visitor_->scope_statements_;
+
+      visitor_->scope_ = scope;
+      visitor_->scope_statements_ = statements;
+      visitor_->NotifyScopeEntry();
+    }
+
+    EnterScope(ASTVisitor *visitor, Scope *scope, Expression *expr)
+        : visitor_(visitor) {
+      saved_scope_ = visitor_->scope_;
+      saved_statements_ = visitor->scope_statements_;
+
+      visitor_->scope_ = scope;
+      visitor_->scope_statements_ = NULL;
+      visitor_->NotifyScopeEntry();
+    }
+
+    ~EnterScope() {
+      visitor_->scope_ = saved_scope_;
+      visitor_->scope_statements_ = saved_statements_;
+    }
+
+   private:
+    ASTVisitor *visitor_;
+    Scope *saved_scope_;
+    ZoneList<Statement *> *saved_statements_;
+  };
+
+  virtual void Visit(AstNode *node) {
+    while (GetCurrentStackPosition() < stack_limit_) {
+      // Increase limit by 1 MiB.
+      isolate_->stack_guard()->SetStackLimit(stack_limit_ - (0x1 << 20));
+      stack_limit_ = isolate_->stack_guard()->real_climit();
+    }
+    GENERATE_AST_VISITOR_SWITCH()
+  }
+
+  // Assuming |statements| are in the same scope the visitor
+  // was initialized with.
+  virtual void StartVisit(ZoneList<Statement *> *statements) {
+    EnterScope enter_scope(this, scope_, statements);
+    AstVisitor::VisitStatements(statements);
+  }
+
+  virtual void StartVisit(Expression *expr) {
+    EnterScope enter_scope(this, scope_, expr);
+    Visit(expr);
+  }
+
+  //
+  // Declarations.
+  //
+
+  virtual void VisitVariableDeclaration(VariableDeclaration *decl) { }
+  virtual void VisitFunctionDeclaration(FunctionDeclaration *decl) { }
+
+  //
+  // Statements.
+  //
+
+  virtual void VisitBlock(Block *block) {
+    if (block->scope() != NULL && ShouldEnterScope()) {
+      EnterScope enter_scope(this, block->scope(), block->statements());
+      VisitStatements(block->statements());
+    } else {
+      // |block| is part of the current scope, visit normally.
+      VisitStatements(block->statements());
+    }
+  }
+
+  virtual void VisitExpressionStatement(ExpressionStatement *stmt) {
+    Visit(stmt->expression());
+  }
+
+  virtual void VisitEmptyStatement(EmptyStatement *stmt) { }
+
+  virtual void VisitSloppyBlockFunctionStatement(
+      SloppyBlockFunctionStatement *stmt) {
+    // Do nothing; don't visit nested function definitions.
+  }
+
+  virtual void VisitIfStatement(IfStatement *stmt) {
+    scope_dependencies_.append(stmt->condition(), NULL);
+    dependency_scopes_.append(scope(), NULL);
+    Visit(stmt->condition());
+    Visit(stmt->then_statement());
+    if (stmt->HasElseStatement())
+      Visit(stmt->else_statement());
+    scope_dependencies_.pop_tail();
+    dependency_scopes_.pop_tail();
+  }
+
+  virtual void VisitContinueStatement(ContinueStatement *stmt) { }
+  virtual void VisitBreakStatement(BreakStatement *stmt) { }
+
+  virtual void VisitReturnStatement(ReturnStatement *stmt) {
+    Visit(stmt->expression());
+  }
+
+  virtual void VisitWithStatement(WithStatement *stmt) {
+    Visit(stmt->expression());
+    if (ShouldEnterScope()) {
+      Zone *zone = stmt->scope()->zone();
+      // TODO: Memory overhead, what if entered multiple times?
+      ZoneList<Statement *> *statements =
+          new (zone) ZoneList<Statement *>(1, zone);
+      statements->Add(stmt->statement(), zone);
+
+      EnterScope enter_scope_(this, stmt->scope(), statements);
+      Visit(stmt->statement());
+    }
+  }
+
+  virtual void VisitSwitchStatement(SwitchStatement *stmt) {
+    scope_dependencies_.append(stmt->tag(), NULL);
+    dependency_scopes_.append(scope(), NULL);
+    Visit(stmt->tag());
+    ZoneList<CaseClause*> *cases = stmt->cases();
+    for (int i = 0; i < cases->length(); i++) {
+      if (!cases->at(i)->is_default())
+        Visit(cases->at(i)->label());
+      VisitStatements(cases->at(i)->statements());
+    }
+    scope_dependencies_.pop_tail();
+    dependency_scopes_.pop_tail();
+  }
+
+  virtual void VisitDoWhileStatement(DoWhileStatement *stmt) {
+    scope_dependencies_.append(stmt->cond(), NULL);
+    dependency_scopes_.append(scope(), NULL);
+    Visit(stmt->cond());
+    Visit(stmt->body());
+    scope_dependencies_.pop_tail();
+    dependency_scopes_.pop_tail();
+  }
+
+  virtual void VisitWhileStatement(WhileStatement *stmt) {
+    scope_dependencies_.append(stmt->cond(), NULL);
+    dependency_scopes_.append(scope(), NULL);
+    Visit(stmt->cond());
+    Visit(stmt->body());
+    scope_dependencies_.pop_tail();
+    dependency_scopes_.pop_tail();
+  }
+
+  virtual void VisitForStatement(ForStatement *stmt) {
+    if (stmt->cond() != NULL) {
+      scope_dependencies_.append(stmt->cond(), NULL);
+      dependency_scopes_.append(scope(), NULL);
+    }
+
+    if (stmt->init() != NULL)
+      Visit(stmt->init());
+    if (stmt->cond() != NULL)
+      Visit(stmt->cond());
+    Visit(stmt->body());
+    if (stmt->next() != NULL)
+      Visit(stmt->next());
+
+    if (stmt->cond() != NULL) {
+      scope_dependencies_.pop_tail();
+      dependency_scopes_.pop_tail();
+    }
+  }
+
+  virtual void VisitForInStatement(ForInStatement *stmt) {
+    Visit(stmt->enumerable());
+    Visit(stmt->each());
+    Visit(stmt->body());
+  }
+
+  virtual void VisitForOfStatement(ForOfStatement *stmt) {
+    Visit(stmt->assign_iterator());
+    Visit(stmt->next_result());
+    Visit(stmt->result_done());
+    Visit(stmt->assign_each());
+    Visit(stmt->body());
+  }
+
+  virtual void VisitTryCatchStatement(TryCatchStatement *stmt) {
+    Visit(stmt->try_block());
+    if (ShouldEnterScope()) {
+      Zone *zone = stmt->scope()->zone();
+      // TODO: Memory overhead, what if entered multiple times?
+      ZoneList<Statement *> *statements =
+          new (zone) ZoneList<Statement *>(1, zone);
+      statements->Add(stmt->catch_block(), zone);
+
+      EnterScope enter_scope(this, stmt->scope(), statements);
+      Visit(stmt->catch_block());
+    }
+  }
+
+  virtual void VisitTryFinallyStatement(TryFinallyStatement *stmt) {
+    Visit(stmt->try_block());
+    Visit(stmt->finally_block());
+  }
+
+  virtual void VisitDebuggerStatement(DebuggerStatement *stmt) { }
+
+  //
+  // Expressions.
+  //
+
+  virtual void VisitFunctionLiteral(FunctionLiteral *literal) { }
+
+  virtual void VisitClassLiteral(ClassLiteral *literal) { }
+
+  virtual void VisitNativeFunctionLiteral(NativeFunctionLiteral *literal) { }
+
+  virtual void VisitConditional(Conditional *cond) {
+    Visit(cond->condition());
+    Visit(cond->then_expression());
+    Visit(cond->else_expression());
+  }
+
+  virtual void VisitVariableProxy(VariableProxy *proxy) { }
+
+  virtual void VisitLiteral(Literal *literal) { }
+
+  virtual void VisitRegExpLiteral(RegExpLiteral *literal) { }
+
+  virtual void VisitObjectLiteral(ObjectLiteral *literal) {
+    for (int i = 0; i < literal->properties()->length(); i++) {
+      ObjectLiteral::Property *property = literal->properties()->at(i);
+      Visit(property->key());
+      Visit(property->value());
+    }
+  }
+
+  virtual void VisitArrayLiteral(ArrayLiteral *literal) {
+    VisitExpressions(literal->values());
+  }
+
+  virtual void VisitAssignment(Assignment *expr) {
+    Visit(expr->target());
+    Visit(expr->value());
+  }
+
+  virtual void VisitYield(Yield *expr) {
+    Visit(expr->expression());
+    Visit(expr->generator_object());
+  }
+
+  virtual void VisitThrow(Throw *expr) {
+    Visit(expr->exception());
+  }
+
+  virtual void VisitProperty(Property *prop) {
+    Visit(prop->obj());
+    Visit(prop->key());
+  }
+
+  virtual void VisitCall(Call *call) {
+    Visit(call->expression());
+    VisitExpressions(call->arguments());
+  }
+
+  virtual void VisitCallNew(CallNew *call) {
+    Visit(call->expression());
+    VisitExpressions(call->arguments());
+  }
+
+  virtual void VisitCallRuntime(CallRuntime *call) {
+    VisitExpressions(call->arguments());
+  }
+
+  virtual void VisitUnaryOperation(UnaryOperation *expr) {
+    Visit(expr->expression());
+  }
+
+  virtual void VisitCountOperation(CountOperation *expr) {
+    Visit(expr->expression());
+  }
+
+  virtual void VisitBinaryOperation(BinaryOperation *expr) {
+    Visit(expr->left());
+    Visit(expr->right());
+  }
+
+  virtual void VisitCompareOperation(CompareOperation *comp) {
+    Visit(comp->left());
+    Visit(comp->right());
+  }
+
+  /* TODO: Esoteric stuff. I'll handle later. */
+  virtual void VisitSpread(Spread *expr) { }
+  virtual void VisitThisFunction(ThisFunction *expr) { }
+  virtual void VisitSuperPropertyReference(SuperPropertyReference *expr) { }
+  virtual void VisitSuperCallReference(SuperCallReference *expr) { }
+  virtual void VisitCaseClause(CaseClause *expr) { }
+  virtual void VisitEmptyParentheses(EmptyParentheses *expr) { }
+  virtual void VisitDoExpression(DoExpression *expr) { }
+  virtual void VisitRewritableExpression(RewritableExpression *expr) { }
+
+ protected:
+  virtual void NotifyScopeEntry() { }
+  virtual bool ShouldEnterScope() { return true; }
+
+ private:
+  Isolate *isolate_;
+  Scope *scope_;
+  ZoneList<Statement *> *scope_statements_;
+  int stack_limit_;
+
+  commons::LinkedList scope_dependencies_;
+  commons::LinkedList dependency_scopes_;
+};
+
+
+class ScopeLocator : public ASTVisitor {
+ public:
+  ScopeLocator(Isolate *isolate, Scope *scope, int position)
+      : ASTVisitor(isolate, scope),
+        position_(position),
+        found_(false),
+        located_scope_(NULL),
+        located_scope_statements_(NULL) {
+  }
+
+  void Locate(ZoneList<Statement *> *statements) {
+    StartVisit(statements);
+  }
+
+  bool found() const { return found_; }
+
+  Scope *LocatedScope() { return located_scope_; }
+
+  ZoneList<Statement *> *LocatedScopeStatements() {
+    return located_scope_statements_;
+  }
+
+  commons::LinkedList *scope_dependencies() { return &scope_dependencies_; }
+
+  commons::LinkedList *dependency_scopes() { return &dependency_scopes_; }
+
+ private:
+  void NotifyScopeEntry() {
+    if (scope()->start_position() == position_) {
+      found_ = true;
+      located_scope_ = scope();
+      located_scope_statements_ = scope_statements();
+      // Make a copy of the current scope dependencies.
+      scope_dependencies_ = *(ASTVisitor::scope_dependencies());
+      dependency_scopes_ = *(ASTVisitor::dependency_scopes());
+    }
+  }
+
+  void Visit(AstNode *node) {
+    if (located_scope_ != NULL)
+      return;
+    ASTVisitor::Visit(node);
+  }
+
+  int position_;
+  bool found_;
+  Scope *located_scope_;
+  ZoneList<Statement *> *located_scope_statements_;
+  commons::LinkedList scope_dependencies_;
+  commons::LinkedList dependency_scopes_;
+};
+
+
+struct ScopeAndNode {
+  Scope *scope;
+  AstNode *node;
+};
+
+class AstNodeLocator : public ASTVisitor {
+ public:
+  AstNodeLocator(Isolate *isolate, Scope *scope, int position)
+      : ASTVisitor(isolate, scope),
+        position_(position),
+        found_(false),
+        located_node_(NULL),
+        located_scope_(NULL) {
+  }
+
+  void Visit(AstNode *node) {
+    if (node->position() == position_ && IsNodeType(node)) {
+      found_ = true;
+      located_node_ = node;
+      located_scope_ = scope();
+      return;
+    }
+    ASTVisitor::Visit(node);
+  }
+
+  void Locate(CompilationInfo *info, ZoneList<Statement *> *statements) {
+    found_ = false;
+
+    ScopeAndNode *cached =
+        isolate()->LocatedScopeAndNode(info, node_type(), position_);
+    if (cached != NULL) {
+      found_ = true;
+      located_node_ = cached->node;
+      located_scope_ = cached->scope;
+    } else {
+      StartVisit(statements);
+      if (found_) {
+        cached = new ScopeAndNode;
+        cached->scope = located_scope_;
+        cached->node = located_node_;
+        isolate()->AddLocatedScopeAndNode(info, node_type(), position_, cached);
+      }
+    }
+  }
+
+  bool found() const { return found_; }
+
+  AstNode *LocatedNode() { return located_node_; }
+
+  Scope *LocatedScope() { return located_scope_; }
+
+ protected:
+  virtual bool IsNodeType(AstNode *node) = 0;
+  virtual AstNode::NodeType node_type() = 0;
+
+ private:
+  int position_;
+  bool found_;
+  AstNode *located_node_;
+  Scope *located_scope_;
+};
+
+#define SPECIALIZE_AST_NODE_LOCATOR(name)                        \
+  class name##Locator : public AstNodeLocator {                  \
+   public:                                                       \
+    name##Locator(Isolate *isolate, Scope *scope, int position)  \
+        : AstNodeLocator(isolate, scope, position) {             \
+    }                                                            \
+    name *LocatedNode() {                                        \
+      return AstNodeLocator::LocatedNode()->As##name();          \
+    }                                                            \
+   private:                                                      \
+    bool IsNodeType(AstNode *node) { return node->Is##name(); }  \
+    AstNode::NodeType node_type() { return AstNode::k##name; }   \
+  };
+
+SPECIALIZE_AST_NODE_LOCATOR(Call)
+SPECIALIZE_AST_NODE_LOCATOR(ReturnStatement)
+SPECIALIZE_AST_NODE_LOCATOR(Property)
+SPECIALIZE_AST_NODE_LOCATOR(ArrayLiteral)
+SPECIALIZE_AST_NODE_LOCATOR(ObjectLiteral)
+SPECIALIZE_AST_NODE_LOCATOR(VariableProxy)
+SPECIALIZE_AST_NODE_LOCATOR(CallRuntime)
+
+#undef SPECIALIZE_AST_NODE_LOCATOR
+
+
+class ScopeDFG {
+ public:
+  ScopeDFG(Isolate *isolate, Scope *scope)
+      : isolate_(isolate),
+        scope_(scope) {
+  }
+
+  static void IterateScopeDFGDestructor(void *key, void *value, void *data) {
+    delete (commons::HashTable *)value;
+  }
+
+  ~ScopeDFG() {
+    nodes_.iterate(IterateScopeDFGDestructor, NULL);
+  }
+
+  Isolate *isolate() const { return isolate_; }
+
+  Scope *scope() const { return scope_; }
+
+  void AddEdge(AstNode *from, AstNode *to) {
+    CHECK(from != to);
+    commons::HashTable *adj_list =
+        reinterpret_cast<commons::HashTable *>(nodes_.get(from));
+    if (adj_list == NULL) {
+      adj_list = new commons::HashTable();
+      nodes_.insert(from, adj_list);
+    }
+    adj_list->insert(to, NULL);
+  }
+
+  static void IteratePropagateTaint(void *key, void *value, void *data) {
+    ScopeDFG *dfg = (ScopeDFG *)data;
+    if (dfg->visited_->search(key))
+      return;
+    dfg->visited_->insert(key, NULL);
+
+    Isolate *isolate = dfg->isolate_;
+    Scope *scope = dfg->scope_;
+    JavaScriptFrame *frame = dfg->frame_;
+    void *fp = frame->fp();
+    Handle<JSFunction> function(frame->function());
+
+    Handle<Object> obj;
+
+    AstNode *node = reinterpret_cast<AstNode *>(key);
+    obj = isolate->LookupObjectMap(fp, node->position(), node->node_type());
+    obj = FilterInvalidV8Objects(isolate, obj);
+
+    if (!obj.is_null() && !isolate->IsDoNotTaint(obj)) {
+      if (obj->IsSmi()) {
+        // TODO: Replace Smi.
+      }
+
+      isolate->SetTaintForV8Object(obj);
+      // This will also set taint for the AST node if obj is
+      // an Smi and was not replaced above - desired behavior.
+      if (!isolate->IsV8ObjectPartiallyTainted(obj)) {
+        isolate->SetTaintForAstNode(function, fp,
+            node->position(), node->node_type());
+      }
+
+      if (dfg->propagated_from_ != NULL) {
+        AstNode *from = reinterpret_cast<AstNode *>(dfg->propagated_from_);
+        Handle<Object> from_obj = dfg->propagated_from_obj_;
+        isolate->AddPropagatedFrom(obj, function, from, from_obj);
+      }
+    }
+
+    commons::HashTable *adj_list =
+        reinterpret_cast<commons::HashTable *>(dfg->nodes_.get(key));
+    if (adj_list != NULL) {
+      void *saved_from = dfg->propagated_from_;
+      Handle<Object> saved_from_obj = dfg->propagated_from_obj_;
+
+      dfg->propagated_from_ = key;
+      dfg->propagated_from_obj_ = obj;
+
+      adj_list->iterate(IteratePropagateTaint, data);
+
+      dfg->propagated_from_ = saved_from;
+      dfg->propagated_from_obj_ = saved_from_obj;
+    }
+  }
+
+  static void IteratePopulateTaintedNodes(void *key, void *value, void *data) {
+    ScopeDFG *dfg = reinterpret_cast<ScopeDFG *>(data);
+    AstNode *node = reinterpret_cast<AstNode *>(key);
+    void *mapped_key =
+        KEY_FROM_POSITION_AND_TYPE(node->position(), node->node_type());
+    if (dfg->ast_taint_table_->search(mapped_key)) {
+      dfg->list_->append(key, value);
+    }
+  }
+
+  bool PropagateTaint(JavaScriptFrame *frame) {
+    if (DoNotPropagate(isolate_)) {
+      return false;
+    }
+
+    Handle<JSFunction> function(frame->function());
+    if (isolate_->IsJSFunctionTainted(function))
+      return TaintLHSNodes(frame);
+
+    commons::HashTable *ast_taint_table =
+        isolate_->GetAstTaintTable(frame->fp(), false);
+    if (ast_taint_table == NULL)
+      return false;
+
+    // Need to make a copy - cannot iterate on the AST taint table itself!
+    //
+    // Also filter out nodes that are not in the DFG.
+    list_ = new commons::LinkedList();
+    //ast_taint_table->iterate(IterateCopyAstTaintTable, this);
+    ast_taint_table_ = ast_taint_table;
+    nodes_.iterate(IteratePopulateTaintedNodes, this);
+
+    frame_ = frame;
+    visited_ = new commons::HashTable();
+    propagated_from_ = NULL;
+    propagated_from_obj_ = Handle<Object>::null();
+    list_->iterate(IteratePropagateTaint, this);
+
+    delete visited_;
+    delete list_;
+
+    return true;
+  }
+
+  static void IterateDoTaintLHSNodes(void *key, void *value, void *data) {
+    ScopeDFG *dfg = (ScopeDFG *)data;
+    Isolate *isolate = dfg->isolate_;
+    Scope *scope = dfg->scope_;
+    JavaScriptFrame *frame = dfg->frame_;
+    void *fp = frame->fp();
+    Handle<JSFunction> function(frame->function());
+
+    Handle<String> report = isolate->GetPropagationPathForJSFunction(function);
+    CHECK(!report.is_null());
+
+    Handle<Object> obj;
+
+    AstNode *node = reinterpret_cast<AstNode *>(key);
+    obj = isolate->LookupObjectMap(fp, node->position(), node->node_type());
+    obj = FilterInvalidV8Objects(isolate, obj);
+
+    if (!obj.is_null() && !isolate->IsDoNotTaint(obj)) {
+      if (obj->IsSmi()) {
+        // TODO: Replace Smi.
+      }
+
+      isolate->SetTaintForV8Object(obj);
+      // This will also set taint for the AST node if obj is
+      // an Smi and was not replaced above - desired behavior.
+      if (!isolate->IsV8ObjectPartiallyTainted(obj)) {
+        isolate->SetTaintForAstNode(function, fp,
+            node->position(), node->node_type());
+      }
+
+      isolate->AddPropagatedFrom(obj, function, report);
+    }
+
+    dfg->propagated_ = true;
+  }
+
+  static void IterateTaintLHSNodes(void *key, void *value, void *data) {
+    commons::HashTable *adj_list =
+        reinterpret_cast<commons::HashTable *>(value);
+    adj_list->iterate(IterateDoTaintLHSNodes, data);
+  }
+
+  // Taint any node that has at least one in edge.
+  bool TaintLHSNodes(JavaScriptFrame *frame) {
+    if (DoNotPropagate(isolate_))
+      return false;
+
+    frame_ = frame;
+    propagated_ = false;
+    nodes_.iterate(IterateTaintLHSNodes, this);
+    return propagated_;
+  }
+
+ private:
+  Isolate *isolate_;
+  Scope *scope_;
+  commons::HashTable nodes_;
+
+  // Taint propagation.
+  JavaScriptFrame *frame_;
+  commons::HashTable *visited_;
+  commons::LinkedList *list_;
+  void *propagated_from_;
+  Handle<Object> propagated_from_obj_;
+  bool propagated_;
+  commons::HashTable *ast_taint_table_;
+};
+
+
+class RHSCollector : public ASTVisitor {
+ public:
+  RHSCollector(Isolate *isolate, Scope *scope)
+      : ASTVisitor(isolate, scope) {
+  }
+
+  void Collect(AstNode *node, commons::LinkedList *output) {
+    output_ = output;
+    Visit(node);
+  }
+
+  void VisitVariableProxy(VariableProxy *proxy) {
+    output_->append(proxy, NULL);
+  }
+
+  void VisitProperty(Property *property) {
+    output_->append(property, NULL);
+  }
+
+  void VisitCall(Call *call) {
+    output_->append(call, NULL);
+  }
+
+ private:
+  commons::LinkedList *output_;
+};
+
+
+class JQueryRHSChecker : public ASTVisitor {
+ public:
+  JQueryRHSChecker(Isolate *isolate, Scope *scope)
+      : ASTVisitor(isolate, scope) {
+  }
+
+  bool Check(Expression *rhs) {
+    state_ = CHECK_START;
+    ASTVisitor::StartVisit(rhs);
+    return (state_ == URL_OR_OPERATION_2) || (state_ == URL_OR_OPERATION_1);
+  }
+
+  /*
+   * A state machine matching RHS of this assignment (i.e., jQuery signature):
+   *
+   * s.url = ( ( url || s.url || ajaxLocation ) + "" )
+   *     .replace( rhash, "" )
+   *     .replace( rprotocol, ajaxLocParts[ 1 ] + "//" );
+   *
+   * Furthermore, some jQuery versions omit the inner replace, that is:
+   *
+   * s.url = ( ( url || s.url || location.href ) + "" )
+   *    .replace( rprotocol, location.protocol + "//" );
+   */
+
+  void Visit(AstNode *node) {
+    if (node->IsCall()) {
+      Call *expr = node->AsCall();
+      if (state_ == CHECK_START && IsOuterReplace(expr)) {
+        state_ = OUTER_REPLACE_CALL;
+        Visit(expr->expression()->AsProperty()->obj());
+      } else if (state_ == OUTER_REPLACE_CALL && IsInnerReplace(expr)) {
+        state_ = INNER_REPLACE_CALL;
+        Visit(expr->expression()->AsProperty()->obj());
+      }
+    } else if (node->IsBinaryOperation()) {
+      BinaryOperation *expr = node->AsBinaryOperation();
+      if ((state_ == INNER_REPLACE_CALL ||
+          state_ == OUTER_REPLACE_CALL) && IsConcatEmptyString(expr)) {
+        state_ = CONCAT_EMPTY_STRING;
+        Visit(expr->left());
+      } else if (state_ == CONCAT_EMPTY_STRING && IsOrOperation(expr)) {
+        state_ = URL_OR_OPERATION_1;
+        Visit(expr->left());
+      } else if (state_ == URL_OR_OPERATION_1 && IsOrOperation(expr)) {
+        state_ = URL_OR_OPERATION_2;
+      }
+    }
+  }
+
+ private:
+  enum State {
+    CHECK_START,
+    OUTER_REPLACE_CALL,
+    INNER_REPLACE_CALL,
+    CONCAT_EMPTY_STRING,
+    URL_OR_OPERATION_1,
+    URL_OR_OPERATION_2
+  };
+
+  bool IsOuterReplace(Call *expr) {
+    if (expr->expression()->IsProperty()) {
+      Property *property = expr->expression()->AsProperty();
+      if (property->key()->IsPropertyName() && HandleStringEquals(
+          property->key()->AsLiteral()->AsPropertyName(), "replace")) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  bool IsInnerReplace(Call *expr) {
+    if (expr->expression()->IsProperty()) {
+      Property *property = expr->expression()->AsProperty();
+      if (property->key()->IsPropertyName() && HandleStringEquals(
+          property->key()->AsLiteral()->AsPropertyName(), "replace")) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  bool IsConcatEmptyString(BinaryOperation *expr) {
+    if (expr->op() == Token::ADD) {
+      if (expr->right()->IsLiteral() && HandleStringEquals(
+          Handle<String>::cast(expr->right()->AsLiteral()->value()), "")) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  bool IsOrOperation(BinaryOperation *expr) {
+    if (expr->op() == Token::OR) {
+      return true;
+    }
+    return false;
+  }
+
+  State state_;
+};
+
+
+class ScopeDFGBuilder : public ASTVisitor {
+ public:
+  ScopeDFGBuilder(Isolate *isolate, Scope *scope,
+      commons::LinkedList *scope_dependencies,
+      commons::LinkedList *dependency_scopes)
+      : ASTVisitor(isolate, scope),
+        nested_property_(false),
+        visit_for_(NONE),
+        control_visit_for_(NONE) {
+    CHECK(scope_dependencies->size() == dependency_scopes->size());
+
+    if (!scope_dependencies->empty()) {
+      // Make a copy, don't operate on the original lists.
+      commons::LinkedList dependencies(*scope_dependencies);
+      commons::LinkedList scopes(*dependency_scopes);
+
+      while (!dependencies.empty()) {
+        AstNode *node = (AstNode *)dependencies.head_key();
+        Scope *scope = (Scope *)scopes.head_key();
+        RHSCollector collector(isolate, scope);
+        collector.Collect(node, &scope_dependencies_);
+
+        dependencies.pop_head();
+        scopes.pop_head();
+      }
+    }
+  }
+
+  ScopeDFG *Build(ZoneList<Statement *> *statements) {
+    nested_property_ = false;
+    dfg_ = new ScopeDFG(isolate(), scope());
+    StartVisit(statements);
+    return dfg_;
+  }
+
+  /*
+   * Control dependencies.
+   */
+
+  void VisitIfStatement(IfStatement *stmt) {
+    ControlVisitForRHS(stmt->condition());
+    ControlVisitForLHS(stmt->then_statement());
+    if (stmt->HasElseStatement())
+      ControlVisitForLHS(stmt->else_statement(), false);
+    PopulateControlDFGEdges();
+  }
+
+  void VisitWhileStatement(WhileStatement *stmt) {
+    ControlVisitForRHS(stmt->cond());
+    ControlVisitForLHS(stmt->body());
+    PopulateControlDFGEdges();
+  }
+
+  void VisitForStatement(ForStatement *stmt) {
+    if (stmt->init() != NULL)
+      Visit(stmt->init());
+
+    if (stmt->cond() != NULL) {
+      ControlVisitForRHS(stmt->cond());
+      ControlVisitForLHS(stmt->body());
+      if (stmt->next() != NULL)
+        ControlVisitForLHS(stmt->next(), false);
+      PopulateControlDFGEdges();
+    } else {
+      Visit(stmt->body());
+      if (stmt->next() != NULL)
+        Visit(stmt->next());
+    }
+  }
+
+  void VisitDoWhileStatement(DoWhileStatement *stmt) {
+    ControlVisitForRHS(stmt->cond());
+    ControlVisitForLHS(stmt->body());
+    PopulateControlDFGEdges();
+  }
+
+  void VisitSwitchStatement(SwitchStatement *stmt) {
+    ControlVisitForRHS(stmt->tag());
+
+    bool first = true;
+    for (int i = 0; i < stmt->cases()->length(); i++) {
+      CaseClause *clause = stmt->cases()->at(i);
+      for (int j = 0; j < clause->statements()->length(); j++) {
+        ControlVisitForLHS(clause->statements()->at(j), first);
+        first = false;
+      }
+    }
+
+    PopulateControlDFGEdges();
+  }
+
+  void VisitConditional(Conditional *expr) {
+    ControlVisitForRHS(expr->condition());
+    ControlVisitForLHS(expr->then_expression());
+    ControlVisitForLHS(expr->else_expression(), false);
+    PopulateControlDFGEdges();
+  }
+
+  // Not sure about these.
+
+  void VisitForInStatement(ForInStatement *stmt) {
+    // Does nothing due to how we handle Property.
+    ASTVisitor::VisitForInStatement(stmt);
+  }
+
+  void VisitForOfStatement(ForOfStatement *stmt) {
+    // Does nothing due to how we handle arrays.
+    ASTVisitor::VisitForOfStatement(stmt);
+  }
+
+  void VisitWithStatement(WithStatement *stmt) {
+    // I don't know WTF this is, seems irrelevant.
+    ASTVisitor::VisitWithStatement(stmt);
+  }
+
+  void VisitTryCatchStatement(TryCatchStatement *stmt) {
+    // What if a tainted object is thrown?
+    ASTVisitor::VisitTryCatchStatement(stmt);
+  }
+
+  /*
+   * Data dependencies.
+   */
+
+  void VisitAssignment(Assignment *expr) {
+    JQueryRHSChecker checker(isolate(), scope());
+    if (!checker.Check(expr->value())) {
+      VisitForRHS(expr->value());
+      VisitForLHS(expr->target());
+      PopulateDFGEdges();
+    }
+  }
+
+  /*
+   * Terminal nodes, they are either RHS or LHS.
+   */
+
+  void VisitVariableProxy(VariableProxy *proxy) {
+    RecordVisitedAstNode(proxy);
+  }
+
+  void VisitProperty(Property *property) {
+    RecordVisitedAstNode(property);
+
+    bool saved_nested_property = nested_property_;
+    nested_property_ = true;
+    ASTVisitor::Visit(property->obj());
+    nested_property_ = saved_nested_property;
+  }
+
+  void VisitCall(Call *call) {
+    RecordVisitedAstNode(call);
+    ASTVisitor::VisitExpressions(call->arguments());
+  }
+
+  // Do nothing for compound types (already handled dynamically).
+  void VisitObjectLiteral(ObjectLiteral *expr) { }
+  void VisitArrayLiteral(ArrayLiteral *expr) { }
+
+ private:
+  bool ShouldEnterScope() { return false; }
+
+  // Collect data flows: RHS -> LHS.
+  enum VisitFor { NONE, LHS, RHS };
+
+  static void IteratePushControlLHS(void *key, void *value, void *data) {
+    commons::LinkedList *lhs = (commons::LinkedList *)key;
+    AstNode *node = (AstNode *)data;
+    lhs->append(node, NULL);
+  }
+
+  void RecordVisitedAstNode(AstNode *node) {
+    if (node->IsLiteral() && !nested_property_)
+      CHECK(node->AsLiteral()->IsPropertyName());
+
+    if (visit_for_ == RHS)
+      CurrentRHS()->append(node, NULL);
+    else if (visit_for_ == LHS && !nested_property_)
+      CurrentLHS()->append(node, NULL);
+
+    if (control_visit_for_ == RHS) {
+      CurrentControlRHS()->append(node, NULL);
+    } else if (control_visit_for_ == LHS &&
+        visit_for_ == LHS && !nested_property_) {
+      control_lhs_.iterate(IteratePushControlLHS, node);
+    }
+  }
+
+  void ControlVisitForRHS(AstNode *node) {
+#ifdef POPULATE_CFG_EDGES
+    commons::LinkedList *rhs = new commons::LinkedList();
+    control_rhs_.prepend(rhs, NULL);
+
+    VisitFor saved_visit_for = control_visit_for_;
+    control_visit_for_ = RHS;
+    Visit(node);
+    control_visit_for_ = saved_visit_for;
+#endif
+  }
+
+  void ControlVisitForLHS(AstNode *node, bool push_new = true) {
+#ifdef POPULATE_CFG_EDGES
+    if (push_new) {
+      commons::LinkedList *lhs = new commons::LinkedList();
+      control_lhs_.prepend(lhs, NULL);
+    }
+
+    VisitFor saved_visit_for = control_visit_for_;
+    control_visit_for_ = LHS;
+    Visit(node);
+    control_visit_for_ = saved_visit_for;
+#endif
+  }
+
+  void VisitForRHS(AstNode *node) {
+    commons::LinkedList *rhs = new commons::LinkedList();
+    rhs_.prepend(rhs, NULL);
+
+    VisitFor saved_visit_for = visit_for_;
+    visit_for_ = RHS;
+    Visit(node);
+    visit_for_ = saved_visit_for;
+  }
+
+  void VisitForLHS(AstNode *node) {
+    commons::LinkedList *lhs = new commons::LinkedList();
+    lhs_.prepend(lhs, NULL);
+
+    VisitFor saved_visit_for = visit_for_;
+    visit_for_ = LHS;
+    Visit(node);
+    visit_for_ = saved_visit_for;
+  }
+
+  struct IterateData {
+    void *data;
+    ScopeDFGBuilder *builder;
+  };
+
+  static void IterateLHS(void *key, void *value, void *data) {
+    IterateData *lhs_data = (IterateData *)data;
+    AstNode *lhs_node = (AstNode *)key;
+    commons::LinkedList *rhs = (commons::LinkedList *)lhs_data->data;
+
+    IterateData rhs_data = { lhs_node, lhs_data->builder };
+    rhs->iterate(IterateRHS, &rhs_data);
+  }
+
+  static void IterateRHS(void *key, void *value, void *data) {
+    AstNode *rhs_node = (AstNode *)key;
+    IterateData *rhs_data = (IterateData *)data;
+    AstNode *lhs_node = (AstNode *)rhs_data->data;
+    rhs_data->builder->dfg_->AddEdge(rhs_node, lhs_node);
+  }
+
+  void PopulateDFGEdges() {
+    commons::LinkedList *rhs = CurrentRHS();
+    commons::LinkedList *lhs = CurrentLHS();
+
+    if (!rhs->empty() && !lhs->empty()){
+      IterateData data = { rhs, this };
+      lhs->iterate(IterateLHS, &data);
+    }
+
+    if (!scope_dependencies_.empty() && !lhs->empty()) {
+      IterateData data = { &scope_dependencies_, this };
+      lhs->iterate(IterateLHS, &data);
+    }
+
+    rhs_.remove(rhs);
+    lhs_.remove(lhs);
+    delete rhs;
+    delete lhs;
+  }
+
+  void PopulateControlDFGEdges() {
+#ifdef POPULATE_CFG_EDGES
+    commons::LinkedList *rhs = CurrentControlRHS();
+    commons::LinkedList *lhs = CurrentControlLHS();
+
+    IterateData data = { rhs, this };
+    lhs->iterate(IterateLHS, &data);
+
+    control_rhs_.remove(rhs);
+    control_lhs_.remove(lhs);
+    delete rhs;
+    delete lhs;
+#endif
+  }
+
+  commons::LinkedList *CurrentControlRHS() {
+    return reinterpret_cast<commons::LinkedList *>(control_rhs_.head_key());
+  }
+
+  commons::LinkedList *CurrentControlLHS() {
+    return reinterpret_cast<commons::LinkedList *>(control_lhs_.head_key());
+  }
+
+  commons::LinkedList *CurrentRHS() {
+    return reinterpret_cast<commons::LinkedList *>(rhs_.head_key());
+  }
+
+  commons::LinkedList *CurrentLHS() {
+    return reinterpret_cast<commons::LinkedList *>(lhs_.head_key());
+  }
+
+  ScopeDFG *dfg_;
+  bool nested_property_;
+  VisitFor visit_for_;
+  VisitFor control_visit_for_;
+  commons::LinkedList rhs_;
+  commons::LinkedList lhs_;
+  commons::LinkedList control_rhs_;
+  commons::LinkedList control_lhs_;
+  commons::LinkedList scope_dependencies_;
+};
+
+
+class ExpressionTaintChecker : public ASTVisitor {
+public:
+  ExpressionTaintChecker(Isolate *isolate, Scope *scope, JavaScriptFrame *frame)
+      : ASTVisitor(isolate, scope),
+        tainted_(false),
+        frame_(frame) {
+  }
+
+  bool Check(Expression *expr) {
+    function_ = Handle<JSFunction>(frame_->function());
+
+    if (isolate()->IsJSFunctionTainted(function_))
+      return true;  // Taint all LHS nodes.
+
+    tainted_ = false;
+    tainted_nodes_.clear();
+    ASTVisitor::StartVisit(expr);
+    return tainted_;
+  }
+
+  void PopulatePropagatedFrom(Handle<Object> obj) {
+    obj = FilterInvalidV8Objects(isolate(), obj);
+    if (obj.is_null())
+      return;
+
+    function_ = Handle<JSFunction>(frame_->function());
+    obj_ = obj;
+
+    if (isolate()->IsJSFunctionTainted(function_)) {
+      Handle<String> report =
+          isolate()->GetPropagationPathForJSFunction(function_);
+      CHECK(!report.is_null());
+      isolate()->AddPropagatedFrom(obj_, function_, report);
+    } else {
+      tainted_nodes_.iterate(IteratePopulatePropagatedFrom, this);
+    }
+  }
+
+  void VisitLiteral(Literal *literal) {
+    // TODO: Can we have a property name here?
+    if (!literal->IsPropertyName() &&
+        isolate()->IsV8ObjectTainted(literal->value())) {
+      tainted_ = true;
+      tainted_nodes_.append(literal, NULL);
+    }
+  }
+
+  void VisitVariableProxy(VariableProxy *proxy) {
+    if (isolate()->IsAstNodeTainted(frame_->fp(),
+        proxy->position(), AstNode::kVariableProxy)) {
+      tainted_ = true;
+      tainted_nodes_.append(proxy, NULL);
+    }
+  }
+
+  void VisitProperty(Property *property) {
+    if (isolate()->IsAstNodeTainted(frame_->fp(),
+        property->position(), AstNode::kProperty)) {
+      tainted_ = true;
+      tainted_nodes_.append(property, NULL);
+    }
+    ASTVisitor::Visit(property->obj());
+  }
+
+  void VisitCall(Call *expr) {
+    if (isolate()->IsAstNodeTainted(frame_->fp(),
+        expr->position(), AstNode::kCall)) {
+      tainted_ = true;
+      tainted_nodes_.append(expr, NULL);
+    }
+    ASTVisitor::VisitExpressions(expr->arguments());
+  }
+
+  // Do nothing for compound types (already handled dynamically).
+  void VisitObjectLiteral(ObjectLiteral *expr) { }
+  void VisitArrayLiteral(ArrayLiteral *expr) { }
+
+private:
+  bool ShouldEnterScope() { return false; }
+
+  static void IteratePopulatePropagatedFrom(void *key,
+                                            void *value,
+                                            void *data) {
+    AstNode *node = (AstNode *)key;
+    ExpressionTaintChecker *checker = (ExpressionTaintChecker *)data;
+    Isolate *isolate = checker->isolate();
+    Scope *scope = checker->scope();
+    Handle<JSFunction> function = checker->function_;
+    void *fp = checker->frame_->fp();
+
+    Handle<Object> obj = checker->obj_;
+    Handle<Object> from_obj;
+
+    if (node->IsLiteral()) {
+      from_obj = node->AsLiteral()->value();
+      from_obj = FilterInvalidV8Objects(isolate, from_obj);
+      isolate->AddPropagatedFrom(obj, function, node, from_obj);
+    } else if (node->IsVariableProxy()) {
+      VariableProxy *proxy = node->AsVariableProxy();
+      from_obj = isolate->LookupObjectMap(fp,
+          proxy->position(), AstNode::kVariableProxy);
+      isolate->AddPropagatedFrom(obj, function, proxy, from_obj);
+    } else if (node->IsProperty()) {
+      Property *property = node->AsProperty();
+      from_obj = isolate->LookupObjectMap(fp,
+          property->position(), AstNode::kProperty);
+      isolate->AddPropagatedFrom(obj, function, property, from_obj);
+    } else if (node->IsCall()) {
+      from_obj = isolate->LookupObjectMap(fp, node->position(), AstNode::kCall);
+      isolate->AddPropagatedFrom(obj, function, node, from_obj);
+    }
+  }
+
+  bool tainted_;
+  commons::LinkedList tainted_nodes_;
+  JavaScriptFrame *frame_;
+
+  Handle<JSFunction> function_;
+  Handle<Object> obj_;
+};
+
+}  // namespace internal
+}  // namespace v8
+
+#endif
diff --git a/src/runtime/runtime.h b/src/runtime/runtime.h
index 38eb51d5a3..7b78728d56 100644
--- a/src/runtime/runtime.h
+++ b/src/runtime/runtime.h
@@ -961,6 +961,35 @@ namespace internal {
   F(ToBooleanIC_Miss, 1, 1)                      \
   F(Unreachable, 0, 1)
 
+#define FOR_EACH_INTRINSIC_TAINT_ANALYSIS(F)         \
+  F(TaintAnalysis_OnScopeExit, 1, 1)                 \
+  F(TaintAnalysis_OnFunctionEnter, 0, 1)             \
+  F(TaintAnalysis_OnVisitCallArguments, 5, 1)        \
+  F(TaintAnalysis_OnVisitReturnStatement, 2, 1)      \
+  F(TaintAnalysis_OnReturnFromCall, 2, 1)            \
+  F(TaintAnalysis_OnVisitVariableProxy, 3, 1)        \
+  F(TaintAnalysis_OnVisitProperty, 4, 1)             \
+  F(TaintAnalysis_OnVisitArrayLiteral, 3, 1)         \
+  F(TaintAnalysis_OnVisitObjectLiteral, 4, 1)        \
+  F(TaintAnalysis_OnTopLevelVarInitialization, 2, 1) \
+  F(TaintAnalysis_ReplaceSmiResult, 1, 1)            \
+  F(TaintAnalysis_ReplaceSmiResult2, 1, 1)           \
+  F(TaintAnalysis_SetTaint, 2, 1)                    \
+  F(TaintAnalysis_SetAsTaintSource, 2, 1)            \
+  F(TaintAnalysis_IsTainted, 3, 1)                   \
+  F(TaintAnalysis_ResetTaint, 3, 1)                  \
+  F(TaintAnalysis_MarkAsTaintSource, 1, 1)           \
+  F(TaintAnalysis_GetPropagationPaths, 1, 1)         \
+  F(TaintAnalysis_SetPropagationPaths, 2, 1)         \
+  F(TaintAnalysis_PrintIsTainted, 2, 1)              \
+  F(TaintAnalysis_DoNotPropagate, 1, 1)              \
+  F(TaintAnalysis_JsonParse, 2, 1)                   \
+  F(TaintAnalysis_JsonStringify, 3, 1)               \
+  F(TaintAnalysis_StringIsTaintedAt, 2, 1)           \
+  F(TaintAnalysis_LogTaintSink, 3, 1)                \
+  F(TaintAnalysis_IsAstNodeTainted, 3, 1)            \
+  F(TaintAnalysis_IsHeapNumber, 1, 1)
+
 #define FOR_EACH_INTRINSIC_RETURN_OBJECT(F) \
   FOR_EACH_INTRINSIC_IC(F)                  \
   FOR_EACH_INTRINSIC_ARRAY(F)               \
@@ -991,7 +1020,8 @@ namespace internal {
   FOR_EACH_INTRINSIC_SYMBOL(F)              \
   FOR_EACH_INTRINSIC_TEST(F)                \
   FOR_EACH_INTRINSIC_TYPEDARRAY(F)          \
-  FOR_EACH_INTRINSIC_WASM(F)
+  FOR_EACH_INTRINSIC_WASM(F)                \
+  FOR_EACH_INTRINSIC_TAINT_ANALYSIS(F)
 
 // FOR_EACH_INTRINSIC defines the list of all intrinsics, coming in 2 flavors,
 // either returning an object or a pair.
